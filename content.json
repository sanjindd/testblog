{"meta":{"title":"三金弟弟'blog","subtitle":"","description":"","author":"sanjindidi","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-11-21T21:38:33.441Z","updated":"2021-11-21T21:38:33.441Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2021-11-21T18:39:09.906Z","updated":"2021-11-21T18:39:09.906Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-11-21T21:29:51.352Z","updated":"2021-11-21T21:29:51.352Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-11-21T18:37:41.016Z","updated":"2021-11-21T18:37:41.016Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"redis","slug":"springsecurity","date":"2021-11-22T05:07:08.000Z","updated":"2021-11-22T13:08:21.796Z","comments":true,"path":"2021/11/22/springsecurity/","link":"","permalink":"http://example.com/2021/11/22/springsecurity/","excerpt":"","text":"1、密码解析器1234567//加密PasswordEncoder pe=new BCryptPasswordEncoder();String encode = pe.encode(&quot;123&quot;);System.out.println(encode);//是否匹配boolean matches = pe.matches(&quot;123&quot;, encode);System.out.println(matches); 2、自定义登录逻辑1、必须注入PasswordEncoder 1234567@Configurationpublic class SecurityConfig &#123; @Bean public PasswordEncoder getPw()&#123; return new BCryptPasswordEncoder(); &#125;&#125; 2、实现UserDetailsService接口 1234567891011121314@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private PasswordEncoder pe; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; //数据库查询用户名是否存在，不存在抛出UsernameNotFoundException if (!&quot;admin&quot;.equals(username))&#123; throw new UsernameNotFoundException(&quot;用户名不存在&quot;); &#125; String password = pe.encode(&quot;123&quot;); return new User(username,password, AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin,normal&quot;)); &#125;&#125; 3、修改登录页面修改配置类 123456789101112131415161718192021222324252627@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; //表单提交 http.formLogin() //根据url为/login的执行登录逻辑 .loginProcessingUrl(&quot;/login&quot;) //自定义登录页面 .loginPage(&quot;/login.html&quot;) //登录成功页面，post请求 .successForwardUrl(&quot;/toMain&quot;); //授权认证 http.authorizeRequests() //不需要被认证 .antMatchers(&quot;/login.html&quot;).permitAll() //所有请求必须经过认证，登录后才能访问 .anyRequest().authenticated(); //关闭csrf保护 http.csrf().disable(); &#125; @Bean public PasswordEncoder getPw()&#123; return new BCryptPasswordEncoder(); &#125;&#125; 12345678@Controllerpublic class LoginController &#123; @RequestMapping(&quot;toMain&quot;) public String toMain()&#123; System.out.println(&quot;执行登录&quot;); return &quot;redirect:main.html&quot;; &#125;&#125; 4、失败跳转 123456789101112131415161718192021222324252627282930313233@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; //表单提交 http.formLogin() //根据url为/login的执行登录逻辑 .loginProcessingUrl(&quot;/login&quot;) //自定义登录页面 .loginPage(&quot;/login.html&quot;) //登录成功页面，post请求 .successForwardUrl(&quot;/toMain&quot;) //登录失败后跳转页面,post请求 .failureForwardUrl(&quot;/toError&quot;); //授权认证 http.authorizeRequests() //不需要被认证 .antMatchers(&quot;/error.html&quot;).permitAll() .antMatchers(&quot;/login.html&quot;).permitAll() //所有请求必须经过认证，登录后才能访问 //regexMatchers :正则匹配 //.regexMatchers(HttpMethod.POST,&quot;/demo&quot;).permitAll(); //.mvcMatchers(&quot;/demo&quot;).servletPath(&quot;/xxxx&quot;).permitAll() .anyRequest().authenticated(); //关闭csrf保护 http.csrf().disable(); &#125; @Bean public PasswordEncoder getPw()&#123; return new BCryptPasswordEncoder(); &#125;&#125; 12345@RequestMapping(&quot;toError&quot;) public String toError()&#123; System.out.println(&quot;执行登录&quot;); return &quot;redirect:error.html&quot;; &#125; 4、登录成功跳转到外站1234567891011121314151617public class MyAuthenticationSuccessHandler implements AuthenticationSuccessHandler &#123; private String url; public MyAuthenticationSuccessHandler(String url) &#123; this.url = url; &#125; @Override public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException &#123; User user = (User) authentication.getPrincipal(); System.out.println(user.getUsername()); System.out.println(user.getAuthorities()); //null System.out.println(user.getPassword()); httpServletResponse.sendRedirect(url); &#125;&#125; 123456789101112131415161718192021222324252627282930313233@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; //表单提交 http.formLogin() //根据url为/login的执行登录逻辑 .loginProcessingUrl(&quot;/login&quot;) //自定义登录页面 .loginPage(&quot;/login.html&quot;) //登录成功页面，post请求 //.successForwardUrl(&quot;/toMain&quot;) //登录成功跳转到外站 .successHandler(new MyAuthenticationSuccessHandler(&quot;http://www.baidu.com&quot;)) //登录失败后跳转页面,post请求 .failureForwardUrl(&quot;/toError&quot;); //授权认证 http.authorizeRequests() //不需要被认证 .antMatchers(&quot;/error.html&quot;).permitAll() .antMatchers(&quot;/login.html&quot;).permitAll() //所有请求必须经过认证，登录后才能访问 .anyRequest().authenticated(); //关闭csrf保护 http.csrf().disable(); &#125; @Bean public PasswordEncoder getPw()&#123; return new BCryptPasswordEncoder(); &#125;&#125; 4、匹配方式12345678http.authorizeRequests() //不需要被认证 .antMatchers(&quot;/error.html&quot;).permitAll() .antMatchers(&quot;/login.html&quot;).permitAll() //.regexMatchers(HttpMethod.POST,&quot;/demo&quot;).permitAll(); //.mvcMatchers(&quot;/demo&quot;).servletPath(&quot;/xxxx&quot;).permitAll() //所有请求必须经过认证，登录后才能访问 .anyRequest().authenticated(); 5、内置访问控制12345permitAllanonymousauthenticatedfullyAuthenticatedrememberMe 6、权限判断123//权限判断//.antMatchers(&quot;/main1.html&quot;).hasAuthority(&quot;admin&quot;) .antMatchers(&quot;/main1.html&quot;).hasAnyAuthority(&quot;ADMIN&quot;,&quot;admin&quot;) 7、角色判断添加角色 123//添加角色 ROLE_角色名 return new User(username,password, AuthorityUtils. commaSeparatedStringToAuthorityList(&quot;admin,normal,ROLE_abc&quot;)); 123//角色判断//.antMatchers(&quot;/main.html&quot;).hasRole(&quot;abc&quot;) .antMatchers(&quot;/main.html&quot;).hasAnyRole(&quot;abc&quot;) 8、IP地址判断12//ip判断.antMatchers(&quot;/main1.html&quot;).hasIpAddress(&quot;127.0.0.1&quot;) 9、自定义403页面实现AccessDeniedHandler 12345678910111213@Componentpublic class MyAccessDeniedHandler implements AccessDeniedHandler &#123; @Override public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException &#123; //响应状态码 httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN); httpServletResponse.setHeader(&quot;Content-Type&quot;,&quot;application/json;charset=utf-8&quot;); PrintWriter writer = httpServletResponse.getWriter(); writer.write(&quot;&#123;\\&quot;status\\&quot;:\\&quot;error\\&quot;,\\&quot;msg\\&quot;:\\&quot;权限不足，请联系管理员\\&quot;&#125;&quot;); writer.flush(); writer.close(); &#125;&#125; 1234567891011@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private MyAccessDeniedHandler myAccessDeniedHandler; @Override protected void configure(HttpSecurity http) throws Exception &#123; //异常处理 http.exceptionHandling() .accessDeniedHandler(myAccessDeniedHandler); &#125;&#125; 10、access（）表达式12.antMatchers(&quot;/login.html&quot;).access(&quot;permitAll()&quot;).antMatchers(&quot;/main.html&quot;).access(&quot;hasRole(&#x27;abc&#x27;)&quot;) 11、access（）结合自定义方法实现权限控制123456789101112@Servicepublic class MyServiceImpl implements MyService &#123; @Override public boolean hasPermission(HttpServletRequest request, Authentication authentication) &#123; Object obj = authentication.getPrincipal(); if (obj instanceof UserDetails) &#123; UserDetails userDetails= (UserDetails) obj; Collection&lt;? extends GrantedAuthority&gt; authorities = userDetails.getAuthorities(); authorities.contains(new SimpleGrantedAuthority(request.getRequestURI())); &#125; return false; &#125; 12return new User(username,password, AuthorityUtils. commaSeparatedStringToAuthorityList(&quot;admin,normal,ROLE_abc,/main.html&quot;)); 1.anyRequest().access(&quot;@myServiceImpl.hasPermission(request,authentication)&quot;); 12、基于注解的访问控制@Secured判断是否具有角色 启动类添加 1@EnableGlobalMethodSecurity(securedEnabled = true) 123456@Secured(&quot;ROLE_abc&quot;) @RequestMapping(&quot;toMain&quot;) public String toMain()&#123; System.out.println(&quot;执行登录&quot;); return &quot;redirect:main.html&quot;; &#125; @PreAuthorize/@PostAuthorizePreAuthorize:访问方法或类在执行之前先判断权限 PostAuthorize：访问方法或类在执行之后判断权限 启动类添加 1@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true) 123456@PreAuthorize(&quot;hasRole(&#x27;abc&#x27;)&quot;) @RequestMapping(&quot;toMain&quot;) public String toMain()&#123; System.out.println(&quot;执行登录&quot;); return &quot;redirect:main.html&quot;; &#125; 13、记住我功能12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.18&lt;/version&gt;&lt;/dependency&gt; 1234spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/security?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=GMTspring.datasource.username=rootspring.datasource.password=root 123456789101112131415161718192021222324252627282930@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private UserDetailsServiceImpl userDetailsService; @Autowired private DataSource dataSource; @Autowired private PersistentTokenRepository persistentTokenRepository; @Override protected void configure(HttpSecurity http) throws Exception //记住我功能 http.rememberMe() //设置失效时间 .tokenValiditySeconds(60) //.rememberMeParameter() //自定义登录逻辑 .userDetailsService(userDetailsService) //持久层对象 .tokenRepository(persistentTokenRepository); &#125; @Bean public PersistentTokenRepository getPersistentTokenRepository()&#123; JdbcTokenRepositoryImpl jdbcTokenRepository=new JdbcTokenRepositoryImpl(); jdbcTokenRepository.setDataSource(dataSource); //自动建表，第一次启动需要，以后需注释 jdbcTokenRepository.setCreateTableOnStartup(true); return jdbcTokenRepository; &#125;&#125; 1记住我：&lt;input type=&quot;checkbox&quot; name=&quot;remember-me&quot; value=&quot;true&quot;&gt; 14、thymeleaf中SpringSecurity的使用12345678&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 1234@RequestMapping(&quot;demo&quot;) public String demo()&#123; return &quot;demo&quot;; &#125; 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot; &gt;&lt;head&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;登录账号：&lt;span sec:authentication=&quot;name&quot;&gt;&lt;/span&gt;&lt;br&gt;登录账号：&lt;span sec:authentication=&quot;principal.username&quot;&gt;&lt;/span&gt;&lt;br&gt;凭证：&lt;span sec:authentication=&quot;credentials&quot;&gt;&lt;/span&gt;&lt;br&gt;权限和角色：&lt;span sec:authentication=&quot;authorities&quot;&gt;&lt;/span&gt;&lt;br&gt;客户端地址：&lt;span sec:authentication=&quot;details.remoteAddress&quot;&gt;&lt;/span&gt;&lt;br&gt;sessionId：&lt;span sec:authentication=&quot;details.sessionId&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt; 123456登录账号：admin登录账号：admin凭证：权限和角色：[/main.html, ROLE_abc, admin, normal]客户端地址：0:0:0:0:0:0:0:1sessionId：5B0D90627080C26C78900EEB010F657C 14、thymeleaf权限判断12345678910通过权限判断&lt;button sec:authorize=&quot;hasAuthority(&#x27;/insert&#x27;)&quot;&gt;新增&lt;/button&gt;&lt;button sec:authorize=&quot;hasAuthority(&#x27;/delete&#x27;)&quot;&gt;删除&lt;/button&gt;&lt;button sec:authorize=&quot;hasAuthority(&#x27;/update&#x27;)&quot;&gt;修改&lt;/button&gt;&lt;button sec:authorize=&quot;hasAuthority(&#x27;/select&#x27;)&quot;&gt;查看&lt;/button&gt;通过角色判断&lt;button sec:authorize=&quot;hasRole(&#x27;abc&#x27;)&quot;&gt;新增&lt;/button&gt;&lt;button sec:authorize=&quot;hasRole(&#x27;abc&#x27;)&quot;&gt;删除&lt;/button&gt;&lt;button sec:authorize=&quot;hasRole(&#x27;abc&#x27;)&quot;&gt;修改&lt;/button&gt;&lt;button sec:authorize=&quot;hasRole(&#x27;abc&#x27;)&quot;&gt;查看&lt;/button&gt; 15、退出登录1234//退出登录 http.logout() //.logoutUrl(&quot;/user/logout&quot;) .logoutSuccessUrl(&quot;/login.html&quot;); 1&lt;a href=&quot;/logout&quot;&gt;退出登录&lt;/a&gt; 16、csrf 跨站请求伪造17、Oauth2简介：OAuth（开放授权）是一个开放标准，允许用户授权第三方移动应用访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方移动应用或分享他们数据的所有内容，OAuth2.0是OAuth协议的延续版本，但不向后兼容OAuth 1.0即完全废止了OAuth1.0。 应用场景：第三方应用授权登录：在APP或者网页接入一些第三方应用时，时长会需要用户登录另一个合作平台，比如QQ，微博，微信的授权登录。 授权模式 授权码模式（authorization code） 简化模式（implicit） 密码模式（resource owner password credentials） 客户端模式（client credentials） 授权码模式授权码模式（authorization code）是功能最完整、流程最严密的授权模式。 （1）用户访问客户端，后者将前者导向认证服务器，假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。 （2）客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌：GET /oauth/token?response_type=code&amp;client_id=test&amp;redirect_uri=重定向页面链接。请求成功返回code授权码，一般有效时间是10分钟。 （3）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。POST /oauth/token?response_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA&amp;redirect_uri=重定向页面链接。 简化模式简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。 流程步骤： （A）客户端将用户导向认证服务器。 （B）用户决定是否给于客户端授权。 （C）假设用户给予授权，认证服务器将用户导向客户端指定的”重定向URI”，并在URI的Hash部分包含了访问令牌。 （D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。 （E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。 （F）浏览器执行上一步获得的脚本，提取出令牌。 （G）浏览器将令牌发给客户端。 请求URL： 123GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1 Host: server.example.com 用户名密码模式密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下。一般不支持refresh token。 步骤说明： （A）用户向客户端提供用户名和密码。 （B）客户端将用户名和密码发给认证服务器，向后者请求令牌。 （C）认证服务器确认无误后，向客户端提供访问令牌。 12345 POST /token HTTP/1.1 Host: server.example.com Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW Content-Type: application/x-www-form-urlencodedgrant_type=password&amp;username=johndoe&amp;password=A3ddj3w 客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。 客户端模式 它的步骤如下： （A）客户端向认证服务器进行身份认证，并要求一个访问令牌。 （B）认证服务器确认无误后，向客户端提供访问令牌。 A步骤中，客户端发出的HTTP请求，包含以下参数： granttype：表示授权类型，此处的值固定为”clientcredentials”，必选项。 scope：表示权限范围，可选项。 123456POST /token HTTP/1.1Host: server.example.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=client_credentials 18、springsecurityOauth2授权码模式12345678910111213141516171819202122232425262728293031323334&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR2&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 12345678910@Servicepublic class UserService implements UserDetailsService &#123; @Autowired private PasswordEncoder pe; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; String password = pe.encode(&quot;123456&quot;); return new User(&quot;admin&quot;,password, AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin&quot;)); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class User implements UserDetails &#123; private String username; private String password; private List&lt;GrantedAuthority&gt; authorities; public User(String username, String password, List&lt;GrantedAuthority&gt; authorities) &#123; this.username = username; this.password = password; this.authorities = authorities; &#125; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; return null; &#125; @Override public String getPassword() &#123; return null; &#125; @Override public String getUsername() &#123; return null; &#125; @Override public boolean isAccountNonExpired() &#123; return false; &#125; @Override public boolean isAccountNonLocked() &#123; return false; &#125; @Override public boolean isCredentialsNonExpired() &#123; return false; &#125; @Override public boolean isEnabled() &#123; return false; &#125;&#125; 123456789101112131415161718192021@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder getPw()&#123; return new BCryptPasswordEncoder(); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.csrf().disable() .authorizeRequests() .antMatchers(&quot;/oauth/**&quot;,&quot;/login/**&quot;,&quot;/logout/**&quot;) .permitAll() .anyRequest() .authenticated() .and() .formLogin() .permitAll(); &#125;&#125; 1234567891011121314151617181920212223@Configuration@EnableAuthorizationServerpublic class AuthorizationServiceConfig extends AuthorizationServerConfigurerAdapter &#123; @Autowired private PasswordEncoder pe; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() //配置client-id .withClient(&quot;admin&quot;) //配置client-secret .secret(pe.encode(&quot;112233&quot;)) //配置访问token的有效期 .accessTokenValiditySeconds(3600) //授权成功后跳转 .redirectUris(&quot;http://www.baidu.com&quot;) //申请的权限范围 .scopes(&quot;all&quot;) //授权类型 .authorizedGrantTypes(&quot;authorization_code&quot;); &#125;&#125; 12345678910111213@Configuration@EnableResourceServerpublic class ResourceServiceConfig extends ResourceServerConfigurerAdapter &#123; @Override public void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest() .authenticated() .and() .requestMatchers() .antMatchers(&quot;/user/**&quot;); &#125;&#125; 19、JWTjson web token 实际上是个字符串 三部分组成：头部、载荷、签名","categories":[{"name":"spring","slug":"spring","permalink":"http://example.com/categories/spring/"},{"name":"springsecurity","slug":"spring/springsecurity","permalink":"http://example.com/categories/spring/springsecurity/"}],"tags":[{"name":"springsecurity","slug":"springsecurity","permalink":"http://example.com/tags/springsecurity/"}]},{"title":"redis","slug":"redis","date":"2021-11-21T23:18:08.000Z","updated":"2021-11-22T11:26:45.099Z","comments":true,"path":"2021/11/22/redis/","link":"","permalink":"http://example.com/2021/11/22/redis/","excerpt":"","text":"一、Linux下redis的安装1、下载redis.tar.gz传输至linux2、解压编译后启动服务12345678910111213141516171819202122232425262728293031[root@localhost ~]# yum -y install centos-release-scl[root@localhost ~]# yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils[root@localhost ~]# scl enable devtoolset-9 bash[root@localhost ~]# gcc -v 查看gcc版本[root@localhost ~]# echo &quot;source /opt/rh/devtoolset-9/enable&quot; &gt;&gt;/etc/profile 长期生效[root@localhost ~]# tar zxvf redis-6.0.6.tar.gz[root@localhost ~]# cd redis-6.0.6[root@localhost redis-6.0.6]# make MALLOC=libc[root@localhost redis-6.0.6]# mkdir -p /usr/local/redis[root@localhost redis-6.0.6]# make PREFIX=/usr/local/redis/ install[root@localhost redis-6.0.6]# cd /usr/local/redis/[root@localhost redis]# cd bin/[root@localhost bin]# ./redis-server 启动服务[root@localhost redis-6.0.6]# cp redis.conf /usr/local/redis/bin/ 拷贝配置文件[root@localhost redis-6.0.6]# cd /usr/local/redis/bin/[root@localhost bin]# vim redis.conf 编辑配置文件daemonize no=====&gt;daemonize yes 后台启动[root@localhost bin]# ./redis-server redis.conf 以后台方式启动服务[root@localhost bin]# ./redis-cli redis客户端[root@localhost bin]# vim redis.confbind 127.0.0.1=======&gt;#bind 127.0.0.1protected-mode yes==========&gt;protected-mode no#requirepass root===============&gt;requirepass root 登录加密 密码root[root@localhost bin]# ps -ef|grep redisroot 9605 1 0 20:58 ? 00:00:03 ./redis-server 127.0.0.1:6379root 9630 8696 0 21:49 pts/0 00:00:00 grep --color=auto redis[root@localhost bin]# kill -9 9605 杀进程[root@localhost bin]# ./redis-server redis.conf 重启服务[root@localhost bin]# firewall-cmd --zone=public --add-port=6379/tcp --permanent 开放端口[root@localhost bin]# firewall-cmd --reload 重启防火墙用Redis Desktop Manager连接到redis 二、redis操作数据类型1、string类型12345678910111213[root@localhost bin]# ./redis-cli -p 6379 -a root 启动客户端127.0.0.1:6379&gt; select 1 //选择数据库OK127.0.0.1:6379&gt; set name zhangsan //存值OK127.0.0.1:6379&gt; get name //取值&quot;zhangsan&quot;127.0.0.1:6379&gt; mset sex 1 address sc //一次性存多个值OK127.0.0.1:6379&gt; mget name sex address //一次性取多个值1) &quot;zhangsan&quot;2) &quot;1&quot;3) &quot;sc&quot; 2、hash类型1234567891011121314151617181920212223242526127.0.0.1:6379&gt; hset user name zhangsan(integer) 1127.0.0.1:6379&gt; hget user name&quot;zhangsan&quot;127.0.0.1:6379&gt; hset user name zhangsan(integer) 1127.0.0.1:6379&gt; hget user name&quot;zhangsan&quot;127.0.0.1:6379&gt; hmset user age 18 sex 1OK127.0.0.1:6379&gt; hmget user name age sex1) &quot;zhangsan&quot;2) &quot;18&quot;3) &quot;1&quot;127.0.0.1:6379&gt; hgetall user1) &quot;name&quot;2) &quot;zhangsan&quot;3) &quot;age&quot;4) &quot;18&quot;5) &quot;sex&quot;6) &quot;1&quot;127.0.0.1:6379&gt; hdel user name age(integer) 2127.0.0.1:6379&gt; hgetall user1) &quot;sex&quot;2) &quot;1&quot; 3、list类型1234567891011121314151617181920212223127.0.0.1:6379&gt; lpush student zhangsan lisi wangwu //左添加(integer) 3127.0.0.1:6379&gt; lrange student 0 21) &quot;wangwu&quot;2) &quot;lisi&quot;3) &quot;zhangsan&quot;127.0.0.1:6379&gt; rpush student zhaosi xiaoming //右添加(integer) 5127.0.0.1:6379&gt; lrange student 0 41) &quot;wangwu&quot;2) &quot;lisi&quot;3) &quot;zhangsan&quot;4) &quot;zhaosi&quot;5) &quot;xiaoming&quot;127.0.0.1:6379&gt; llen student //数据总数(integer) 5127.0.0.1:6379&gt; lrem student 1 xiaoming //删除数据 从左往右删(integer) 1127.0.0.1:6379&gt; lrange student 0 41) &quot;wangwu&quot;2) &quot;lisi&quot;3) &quot;zhangsan&quot;4) &quot;zhaosi&quot; 4、set类型（无序，内部排序）1234567891011121314127.0.0.1:6379&gt; sadd letters aaa bbb ccc ddd(integer) 4127.0.0.1:6379&gt; smembers letters1) &quot;bbb&quot;2) &quot;ddd&quot;3) &quot;ccc&quot;4) &quot;aaa&quot;127.0.0.1:6379&gt; scard letters //查看set的记录数(integer) 4127.0.0.1:6379&gt; srem letters aaa ccc //删除记录(integer) 2127.0.0.1:6379&gt; smembers letters1) &quot;bbb&quot;2) &quot;ddd&quot; 5、sorted set类型（排序）1234567891011121314127.0.0.1:6379&gt; zadd score 7 zhangsan 4 lisi 1 wanger //根据峰值排序(integer) 3127.0.0.1:6379&gt; zrange score 0 21) &quot;wanger&quot;2) &quot;lisi&quot;3) &quot;zhangsan&quot;127.0.0.1:6379&gt; zcard score(integer) 3127.0.0.1:6379&gt; zrem score zhangsan(integer) 1127.0.0.1:6379&gt; zrange score 0 11) &quot;wanger&quot;2) &quot;lisi&quot; 三、通用命令1234567891011121314151617181920212223242526272829303132127.0.0.1:6379&gt; set cart:user01:item01 appleOK127.0.0.1:6379&gt; get cart:user01:item01&quot;apple&quot;127.0.0.1:6379&gt; set code test ex 10 //设置失效时间OK127.0.0.1:6379&gt; ttl code(integer) 6127.0.0.1:6379&gt; get code&quot;test&quot;127.0.0.1:6379&gt; ttl code(integer) 1127.0.0.1:6379&gt; ttl code(integer) -2127.0.0.1:6379&gt; get code(nil)127.0.0.1:6379&gt; expire code 10 //已经存在的key设置失效时间(integer) 1127.0.0.1:6379&gt; ttl code(integer) 6127.0.0.1:6379&gt; get code&quot;test&quot;127.0.0.1:6379&gt; get code(nil)127.0.0.1:6379&gt; set code test px 100 xx //xx:key存在才能设置失效时间(nil)127.0.0.1:6379&gt; set code test px 100 nx //nx:key不存在设置失效时间OK127.0.0.1:6379&gt; del address //通用删除(integer) 1127.0.0.1:6379&gt; del user(integer) 1 四、java 通过 jedis连接操作redis1、添加依赖123456789101112131415161718192021222324252627282930&lt;dependencies&gt; &lt;!--redis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!--采用jedis排除lettuce依赖--&gt; &lt;exclusion&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--jedis--&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--test--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、配置文件 12345678910111213141516171819spring: redis: host: 192.168.159.180 port: 6379 password: root database: 0 #连接超时时间 timeout: 10000ms jedis: pool: #最大连接数 max-active: 1024 #最大连接阻塞等待时间 max-wait: 10000ms #最大空闲连接数 max-idle: 200 #最小空闲连接数 min-idle: 5 2、测试连接12345678910111213141516171819202122232425262728293031@Test public void initConnect()&#123; Jedis jedis=new Jedis(&quot;192.168.159.180&quot;,6379); jedis.auth(&quot;root&quot;); jedis.select(1); String result = jedis.ping(); System.out.println(result); jedis.set(&quot;name&quot;,&quot;zhangsan&quot;); String name = jedis.get(&quot;name&quot;); System.out.println(name); if (jedis!=null)&#123; jedis.close(); &#125; &#125;@Test public void initConnect02()&#123; //初始化连接池对象 JedisPool jedisPool=new JedisPool(new JedisPoolConfig(),&quot;192.168.159.180&quot;, 6379,10000,&quot;root&quot;); //从连接池获得jedis对象 Jedis jedis = jedisPool.getResource(); jedis.select(2); String result = jedis.ping(); System.out.println(result); jedis.set(&quot;name&quot;,&quot;zhangsan&quot;); String name = jedis.get(&quot;name&quot;); System.out.println(name); if (jedis!=null)&#123; jedis.close(); &#125; &#125; 3、线程池初始化一次12345678910111213141516171819202122232425262728293031323334353637@Configurationpublic class RedisConfig &#123; //服务器地址 @Value(&quot;$&#123;spring.redis.host&#125;&quot;) private String host; //服务器端口 @Value(&quot;$&#123;spring.redis.port&#125;&quot;) private int port; //访问密码 @Value(&quot;$&#123;spring.redis.password&#125;&quot;) private String password; //连接超时时间 @Value(&quot;$&#123;spring.redis.timeout&#125;&quot;) private String timeout; //最大连接数 @Value(&quot;$&#123;spring.redis.jedis.pool.max-active&#125;&quot;) private int maxTotal; //最大连接阻塞等待时间 @Value(&quot;$&#123;spring.redis.jedis.pool.max-wait&#125;&quot;) private String maxWait; //最大空闲连接数量 @Value(&quot;$&#123;spring.redis.jedis.pool.max-idle&#125;&quot;) private int maxIdle; //最小空闲连接数量 @Value(&quot;$&#123;spring.redis.jedis.pool.min-idle&#125;&quot;) private int minIdle; @Bean public JedisPool getJedisPool()&#123; JedisPoolConfig jedisPoolConfig=new JedisPoolConfig(); jedisPoolConfig.setMaxTotal(maxTotal); jedisPoolConfig.setMaxWaitMillis(Long.valueOf(maxWait.substring(0,maxWait.length()-2))); jedisPoolConfig.setMaxIdle(maxIdle); jedisPoolConfig.setMinIdle(minIdle); JedisPool jedisPool=new JedisPool(jedisPoolConfig,host,port,Integer.valueOf(timeout.substring(0,timeout.length()-2)),password); return jedisPool; &#125;&#125; 12345678910111213@Autowired private JedisPool jedisPool; private Jedis jedis=null; @BeforeAll public void initConn()&#123; jedis=jedisPool.getResource(); &#125; @AfterAll public void closetConn()&#123; if (jedis!=null)&#123; jedis.close(); &#125; &#125; 5、jedis操作string1234567891011@Test public void testHash()&#123; jedis.set(&quot;name&quot;,&quot;lisi&quot;); String s = jedis.get(&quot;name&quot;); System.out.println(s); //奇数位是key，偶数位是value jedis.mset(&quot;address&quot;,&quot;sc&quot;,&quot;sex&quot;,&quot;1&quot;); List&lt;String&gt; list = jedis.mget(&quot;name&quot;, &quot;address&quot;, &quot;sex&quot;); list.forEach(System.out::print); jedis.del(&quot;name&quot;); &#125; 6、操作hash1234567891011121314151617@Test public void testHash()&#123; jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;zhangsan&quot;); String name = jedis.hget(&quot;user&quot;, &quot;name&quot;); Map&lt;String,String&gt; map=new HashMap&lt;&gt;(); System.out.println(name); map.put(&quot;age&quot;,&quot;20&quot;); map.put(&quot;sex&quot;,&quot;1&quot;); jedis.hmset(&quot;user&quot;,map); List&lt;String&gt; list = jedis.hmget(&quot;user&quot;, &quot;age&quot;, &quot;sex&quot;); list.forEach(System.out::print); Map&lt;String, String&gt; map1 = jedis.hgetAll(&quot;user&quot;); map1.entrySet().forEach(e-&gt;&#123; System.out.println(e.getKey()+&quot;-----&gt;&quot;+e.getValue()); &#125;); jedis.hdel(&quot;user&quot;,&quot;name&quot;); &#125; 7、操作list123456789101112131415@Test public void testList()&#123; jedis.lpush(&quot;student&quot;,&quot;zhagnsan&quot;,&quot;lisi&quot;); jedis.rpush(&quot;student&quot;,&quot;wangwu&quot;,&quot;mazi&quot;); List&lt;String&gt; list = jedis.lrange(&quot;student&quot;, 0, 3); list.forEach(System.out::print); Long total = jedis.llen(&quot;student&quot;); System.out.println(total); jedis.lrem(&quot;studnet&quot;,1,&quot;lisi&quot;); //弹出要删除redis里面的数据 String left = jedis.lpop(&quot;student&quot;); String right = jedis.rpop(&quot;student&quot;); System.out.println(left); System.out.println(right); &#125; 8、操作set12345678910@Test public void testSet()&#123; jedis.sadd(&quot;demo&quot;,&quot;aaa&quot;,&quot;ccc&quot;,&quot;bbb&quot;,&quot;ggg&quot;); Set&lt;String&gt; set = jedis.smembers(&quot;demo&quot;); set.forEach(System.out::print); Long total = jedis.scard(&quot;demo&quot;); System.out.println(total); jedis.srem(&quot;demo&quot;,&quot;aaa&quot;); &#125; 9、操作sortedset123456789101112131415@Test public void SortedSet()&#123; Map&lt;String,Double&gt; map=new HashMap&lt;&gt;(); map.put(&quot;zhangsan&quot;,7D); map.put(&quot;lisi&quot;,3D); map.put(&quot;wangwu&quot;,1D); map.put(&quot;maer&quot;,4D); map.put(&quot;xiaozi&quot;,2D); jedis.zadd(&quot;qwe&quot;,map); Set&lt;String&gt; set = jedis.zrange(&quot;qwe&quot;, 0, 4); set.forEach(System.out::println); Long total = jedis.zcard(&quot;qwe&quot;); System.out.println(total); jedis.zrem(&quot;qwe&quot;,&quot;zhangsan&quot;); &#125; 10、层级目录形式存储数据123456@Testpublic void testDir()&#123; jedis.set(&quot;dir1:dir2:dir3&quot;,&quot;apple&quot;); String s = jedis.get(&quot;dir1:dir2:dir3&quot;); System.out.println(s);&#125; 11、设置失效时间1234567891011121314151617181920212223242526 @Test public void testExpire()&#123;// jedis.set(&quot;code&quot;,&quot;test&quot;);// jedis.expire(&quot;code&quot;,30); //jedis.pexpire(&quot;code&quot;,30000);// Long ttl = jedis.ttl(&quot;code&quot;);// System.out.println(ttl); // jedis.setex(&quot;code&quot;,30,&quot;test&quot;); jedis.psetex(&quot;code&quot;,30000,&quot;test&quot;); Long ttl = jedis.pttl(&quot;code&quot;); System.out.println(ttl); &#125; @Test public void testNxXx()&#123; SetParams setParams=new SetParams(); //nx xx的用法 //不存在的时候才能成功 setParams.nx(); //存在的时候才能成功 //setParams.xx(); //设置失效时间 秒 //setParams.ex(30); setParams.px(30000);//毫秒 jedis.set(&quot;code&quot;,&quot;test&quot;,setParams); &#125; 12、通用操作123456789@Test public void testComm()&#123; //查询数据库key的数量 Long size = jedis.dbSize(); System.out.println(size); //查询当前数据库的所有key Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;); keys.forEach(System.out::println); &#125; 13、事务12345678910@Test public void testMulti()&#123; //开启事务 Transaction tx = jedis.multi(); tx.set(&quot;tel&quot;,&quot;10086&quot;); //提交事务 //tx.exec(); //回滚事务 tx.discard() &#125; 14、操作byte数组123456789101112131415@Test public void testByte() throws IOException, ClassNotFoundException &#123; User user=new User(); user.setId(1); user.setUsername(&quot;zhangsan&quot;); user.setPassword(&quot;123456&quot;); //序列化为byte数组 byte[] userKey = SerializationUtils.serialize(user.getId()); byte[] userValue = SerializationUtils.serialize(user); jedis.set(userKey,userValue); byte[] bytes = jedis.get(userKey); //反序列化 User user1 = SerializationUtils.deserialize(jedis.get(bytes),User.class); System.out.println(user1); &#125; 五、redis持久化方案1、杀死进程模拟断电，redis内存数据消失1234567[root@localhost ~]# cd /usr/local/redis/bin/[root@localhost bin]# ./redis-cli -p 6379 -a rootWarning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.127.0.0.1:6379&gt; set name zhangsanOK[root@localhost bin]# kill -9 9768[root@localhost bin]# ./redis-server redis.conf 2、方案1 bgsave缺点：每次存放数据即要一次bgsave 123127.0.0.1:6379&gt; bgsaveBackground saving started 3、方案2 rdb优点：自动化 缺点：存在丢失数据 1234567891011121314151617[root@localhost bin]# vim redis.conf 338 # The filename where to dump the DB 339 dbfilename dump.rdb //持久化配置文件 [root@localhost ~]# cd /usr/local/redis/bin/[root@localhost bin]# ll总用量 18576-rw-r--r--. 1 root root 665 11月 18 07:03 dump.rdb-rwxr-xr-x. 1 root root 797760 11月 17 20:43 redis-benchmark-rwxr-xr-x. 1 root root 5664872 11月 17 20:43 redis-check-aof-rwxr-xr-x. 1 root root 5664872 11月 17 20:43 redis-check-rdb-rwxr-xr-x. 1 root root 1125272 11月 17 20:43 redis-cli-rw-r--r--. 1 root root 83387 11月 17 22:22 redis.conflrwxrwxrwx. 1 root root 12 11月 17 20:43 redis-sentinel -&gt; redis-server-rwxr-xr-x. 1 root root 5664872 11月 17 20:43 redis-serversave 900 1 //900秒内 有一个 key发生变化 就持久化到磁盘save 300 10save 60 10000 4、方案3 aof优点：实时记录命令 缺点：文件过大 加载慢 123[root@localhost bin]# vim redis.conf appendonly no===========&gt;appendonly yes //开启后命令就会追加到appendonly.aof文件appendfilename &quot;appendonly.aof&quot; 六、redis主从复用1、读写分离 ​ 2、哨兵配置主服务器挂掉，哨兵选举从服务器中的一个变成新的主服务器，具备读写能力，之前的主服务器修好后，只能变成从服务器，只有读能力。 八、redisj集群1、主从缺点：没有解决写压力，浪费资源九、SpringDataRedis1、连接redis操作string1234567891011121314151617181920212223242526&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--连接池依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 12345678910111213spring: redis: host: 192.168.159.180 port: 6379 password: root database: 0 timeout: 10000ms lettuce: pool: max-active: 1024 max-wait: 10000ms max-idle: 200 min-idle: 5 12345678910111213 @Autowired private RedisTemplate&lt;String,String&gt; redisTemplate; @Autowired private StringRedisTemplate stringRedisTemplate; @Test void contextLoads() &#123;// ValueOperations ops = redisTemplate.opsForValue();// ops.set(&quot;name&quot;,&quot;majiaxin&quot;); ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue(); ops.set(&quot;age&quot;,&quot;1&quot;); String age = ops.get(&quot;age&quot;); System.out.println(age); &#125; 2、序列化问题1234567891011121314151617@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String,Object&gt; redisTemplate(LettuceConnectionFactory lettuceConnectionFactory)&#123; RedisTemplate&lt;String,Object&gt; redisTemplate=new RedisTemplate&lt;&gt;(); //为String类型的key设置序列化 redisTemplate.setKeySerializer(new StringRedisSerializer()); //为String类型的value设置序列化 redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer()); //为hash类型的key设置序列化 redisTemplate.setHashKeySerializer(new StringRedisSerializer()); //为hash类型的value设置序列化 redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer()); redisTemplate.setConnectionFactory(lettuceConnectionFactory); return redisTemplate; &#125;&#125; 12345678910111213@Autowiredprivate RedisTemplate redisTemplate;@Testpublic void testSerial()&#123; User user=new User(); user.setId(1); user.setName(&quot;majiaxin&quot;); user.setAge(20); ValueOperations ops = redisTemplate.opsForValue(); ops.set(&quot;user&quot;,user); Object user1 = ops.get(&quot;user&quot;); System.out.println(user1);&#125; 3、操作string类型123456789101112131415161718@Test public void testString()&#123; ValueOperations ops = redisTemplate.opsForValue(); ops.set(&quot;name&quot;,&quot;test&quot;); String name = (String) ops.get(&quot;name&quot;); System.out.println(name); Map&lt;String,String&gt; map=new HashMap&lt;&gt;(); map.put(&quot;age&quot;,&quot;20&quot;); map.put(&quot;address&quot;,&quot;sc&quot;); ops.multiSet(map); List&lt;String&gt; keys=new ArrayList&lt;&gt;(); keys.add(&quot;name&quot;); keys.add(&quot;age&quot;); keys.add(&quot;address&quot;); List values = ops.multiGet(keys); values.forEach(System.out::println); redisTemplate.delete(&quot;name&quot;); &#125; 4、操作hash12345678910111213141516171819202122@Test public void testHash()&#123; HashOperations ops = redisTemplate.opsForHash(); ops.put(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;); String name = (String) ops.get(&quot;user&quot;, &quot;name&quot;); System.out.println(name); Map&lt;String,String&gt; map=new HashMap&lt;&gt;(); map.put(&quot;age&quot;,&quot;20&quot;); map.put(&quot;address&quot;,&quot;sc&quot;); ops.putAll(&quot;user&quot;,map); List&lt;String&gt; keys=new ArrayList&lt;&gt;(); keys.add(&quot;name&quot;); keys.add(&quot;age&quot;); keys.add(&quot;address&quot;); List user = ops.multiGet(&quot;user&quot;, keys); user.forEach(System.out::println); Map&lt;String,String&gt; entries = ops.entries(&quot;user&quot;); entries.entrySet().forEach(e-&gt;&#123; System.out.println(e.getKey()+&quot;--&gt;&quot;+e.getValue()); &#125;); ops.delete(&quot;user&quot;,&quot;name&quot;,&quot;age&quot;); &#125; 5、操作list12345678910111213141516@Test public void testList()&#123; ListOperations ops = redisTemplate.opsForList();// ops.leftPush(&quot;student&quot;,&quot;lisi&quot;);// ops.leftPush(&quot;student&quot;,&quot;wangwu&quot;);// ops.rightPush(&quot;student&quot;,&quot;zhaosi&quot;);// List list = ops.range(&quot;student&quot;, 0, 2);// list.forEach(System.out::println);// Long total = ops.size(&quot;student&quot;);// System.out.println(total);// ops.remove(&quot;student&quot;,1,&quot;lisi&quot;); ops.leftPush(&quot;student&quot;,&quot;zhaosi&quot;,&quot;add&quot;); ops.leftPop(&quot;student&quot;); ops.rightPop(&quot;student&quot;); &#125; 5、操作set1234567891011 @Testpublic void testSet()&#123; SetOperations ops = redisTemplate.opsForSet(); String[] letters=new String[]&#123;&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;&#125;; //ops.add(&quot;letters&quot;,&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;); ops.add(&quot;letters&quot;,letters); Set set = ops.members(&quot;letters&quot;); set.forEach(System.out::println); ops.remove(&quot;letters&quot;,&quot;aaa&quot;);&#125; 5、操作sortedSet12345678910111213141516171819@Test public void testSortedSet()&#123; ZSetOperations ops = redisTemplate.opsForZSet(); ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple1=new DefaultTypedTuple&lt;&gt;(&quot;wangwu&quot;,4D); ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple2=new DefaultTypedTuple&lt;&gt;(&quot;zhaosi&quot;,1D); ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple3=new DefaultTypedTuple&lt;&gt;(&quot;wanger&quot;,3D); ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple4=new DefaultTypedTuple&lt;&gt;(&quot;yianqi&quot;,5D); Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples=new HashSet&lt;&gt;(); tuples.add(objectTypedTuple1); tuples.add(objectTypedTuple2); tuples.add(objectTypedTuple3); tuples.add(objectTypedTuple4); ops.add(&quot;score&quot;,tuples); Set set = ops.range(&quot;score&quot;, 0, 3); set.forEach(System.out::println); Long total = ops.size(&quot;score&quot;); System.out.println(total); ops.remove(&quot;score&quot;,&quot;zhaosi&quot;); &#125; 6、通用12345678910111213141516 @Test public void testAllKey()&#123; Set keys = redisTemplate.keys(&quot;*&quot;); keys.forEach(System.out::println); &#125;@Test public void testExpire()&#123; ValueOperations ops = redisTemplate.opsForValue(); //添加key设置失效时间 //1、ops.set(&quot;code&quot;,&quot;test&quot;,30, TimeUnit.SECONDS); //给已经存在的key添加失效时间 redisTemplate.expire(&quot;code&quot;,30,TimeUnit.SECONDS); //查看失效时间 Long expire = redisTemplate.getExpire(&quot;code&quot;); System.out.println(expire); &#125; 十、key的过期淘汰机制1、定期删除redis每隔100s随机抽取一些设置了过期时间的key，检查是否过期，过期则删除 2、惰性删除有些key可能一直不会被删除，所以用户查询时，检查key是否过期，过期则删除这个key。 3、内存淘汰机制有些key用户可能一直不访问。 10、缓存击穿一个热点的Key，有大并发集中对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。 解决方案： 1、如果业务允许的话，对于热点的key可以设置永不过期的key。 2、使用互斥锁。如果缓存失效的情况，只有拿到锁才可以查询数据库，降低了在同一时刻打在数据库上的请求，防止数据库打死。当然这样会导致系统的性能变差。 11、缓存穿透我们使用Redis大部分情况都是通过Key查询对应的值，假如发送的请求传进来的key是不存在Redis中的，那么就查不到缓存，查不到缓存就会去数据库查询。假如有大量这样的请求，这些请求像“穿透”了缓存一样直接打在数据库上，这种现象就叫做缓存穿透。 12、缓存雪崩当某一个时刻出现大规模的缓存失效的情况，那么就会导致大量的请求直接打在数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。 解决方案： 1、在原有的失效时间上加上一个随机值，比如1-5分钟随机。这样就避免了因为采用相同的过期时间导致的缓存雪崩。 如果真的发生了缓存雪崩，有没有什么兜底的措施？ 2、使用熔断机制。当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上。至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。 3、提高数据库的容灾能力，可以使用分库分表，读写分离的策略。 4、为了防止Redis宕机导致缓存雪崩的问题，可以搭建Redis集群，提高Redis的容灾性。","categories":[{"name":"redis","slug":"redis","permalink":"http://example.com/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]}],"categories":[{"name":"spring","slug":"spring","permalink":"http://example.com/categories/spring/"},{"name":"springsecurity","slug":"spring/springsecurity","permalink":"http://example.com/categories/spring/springsecurity/"},{"name":"redis","slug":"redis","permalink":"http://example.com/categories/redis/"}],"tags":[{"name":"springsecurity","slug":"springsecurity","permalink":"http://example.com/tags/springsecurity/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]}