{"meta":{"title":"三金弟弟'blog","subtitle":"","description":"","author":"sanjindidi","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-11-21T21:38:33.441Z","updated":"2021-11-21T21:38:33.441Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2021-11-21T18:39:09.906Z","updated":"2021-11-21T18:39:09.906Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-11-21T21:29:51.352Z","updated":"2021-11-21T21:29:51.352Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-11-21T18:37:41.016Z","updated":"2021-11-21T18:37:41.016Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"jdk8新特性","slug":"jdk8新特性","date":"2021-11-25T09:10:46.000Z","updated":"2021-11-25T17:12:14.828Z","comments":true,"path":"2021/11/25/jdk8新特性/","link":"","permalink":"http://example.com/2021/11/25/jdk8%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"","text":"一、Lambda 表达式Lambda 表达式，也可称为闭包。 Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。 使用 Lambda 表达式可以使代码变的更加简洁紧凑。 以下是lambda表达式的重要特征: 可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。 可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。 可选的大括号：如果主体包含了一个语句，就不需要使用大括号。 可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。 函数式接口：函数式接口（functional interface 也叫功能性接口，其实是同一个东西）。简单来说，函数式接口是只包含一个方法的接口。比如Java标准库中的java.lang.Runnable和 java.util.Comparator都是典型的函数式接口。java 8提供 @FunctionalInterface作为注解,这个注解是非必须的，只要接口符合函数式接口的标准（即只包含一个方法的接口），虚拟机会自动判断， 但 最好在接口上使用注解@FunctionalInterface进行声明，以免团队的其他人员错误地往接口中添加新的方法。 实例：12345678910// 1. 不需要参数,返回值为 5 () -&gt; 5 // 2. 接收一个参数(数字类型),返回其2倍的值 x -&gt; 2 * x // 3. 接受2个参数(数字),并返回他们的差值 (x, y) -&gt; x – y // 4. 接收2个int型整数,返回他们的和 (int x, int y) -&gt; x + y // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void) (String s) -&gt; System.out.print(s) 123456789101112131415161718192021222324public class Lambda &#123; //定义一个接口 interface Operation&#123; int operation(int a,int b); &#125; public static void main(String[] args) &#123; //申明类型 Operation add=( int a, int b) -&gt; a + b; //不申明类型 Operation sub = ( a, b ) -&gt; a - b; //大括号中的返回语句 Operation mul=(int a,int b) -&gt; &#123; return a * b ;&#125;; // 没有大括号及返回语句 Operation div=( a, b ) -&gt; a / b ; //以前写法 Operation add2=new Operation() &#123; @Override public int operation(int a, int b) &#123; return a+b; &#125; &#125;; &#125;&#125; 使用 Lambda 表达式需要注意以下两点： Lambda 表达式主要用来定义行内执行的方法类型接口 Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。 变量作用域：lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。 ambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义） 12345678910111213public class Lambda &#123; final static String mes = &quot;Hello! &quot;; public static void main(String args[])&#123; GreetingService greetService1 = message -&gt; System.out.println(mes + message); greetService1.sayMessage(&quot;world&quot;); &#125; interface GreetingService &#123; void sayMessage(String message); &#125;&#125; 输出结果为：Hello! world 在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。 1234567891011public class Lambda &#123; public static void main(String args[])&#123; String mes=&quot;&quot;; GreetingService greetService1 = mes -&gt;//编译不通过 System.out.println(mes); greetService1.sayMessage(&quot;hello&quot;); &#125; interface GreetingService &#123; void sayMessage(String message); &#125;&#125; 二、方法引用方法引用通过方法的名字来指向一个方法。 方法引用可以使语言的构造更紧凑简洁，减少冗余代码。 方法引用使用一对冒号 :: 一、类::静态方法123456789101112131415161718public class Lambda &#123; public static void main(String args[])&#123; GreetingService greetService1 = SayMessage::sayHello; greetService1.sayMessage(&quot;world&quot;); //相当于以下效果，直接把类的静态方法写在Lambda体里 GreetingService greetService2 =mes -&gt;SayMessage.sayHello(mes); greetService2.sayMessage(&quot;hello&quot;); &#125;&#125;interface GreetingService &#123; void sayMessage(String message);&#125;class SayMessage&#123; public static void sayHello(String message)&#123; System.out.println(message); &#125;&#125; 在这段代码中，把sayHello类的sayHello（）方法作为了Lambda表达式的Lambda体。 效果和Lambda表达式相同，当调用接口的sayMessage()方法时，调用的实际上是sayHello类的sayHello()方法。 注意： 1，参数列表必须一致，才能用方法引用，否则编译报错。 2，必须标记为静态方法，否则编译会报错。 二、对象::实例方法我们可以把一个实例的非静态方法作为Lambda体，比如这样： 12345678910111213141516171819public class Lambda &#123; public static void main(String args[])&#123; SayMessage sayMessage=new SayMessage(); GreetingService greetService1 = sayMessage::sayHello; greetService1.sayMessage(&quot;world&quot;); //相当于以下效果，直接把类的静态方法写在Lambda体里 GreetingService greetService2 =mes -&gt;sayMessage.sayHello(mes); greetService2.sayMessage(&quot;hello&quot;); &#125;&#125;interface GreetingService &#123; void sayMessage(String message);&#125;class SayMessage&#123; public void sayHello(String message)&#123; System.out.println(message); &#125;&#125; 注意： 1，这种模式下,不能标记为静态方法，否则编译会报错。 2，这里的对象可以是父对象，比如可以使用：（如果有父类有这个方法的话）。 1super:: sayHello 三、类::实例方法这种模式并不是要直接调用类的实例方法，这样显然连编译都过不去。 这种模式实际上是 对象::实例方法模式的一种变形，当一个对象调用方法时，方法的某个参数是函数式接口，而且函数式接口的方法参数列表的第一个参数就是调用者对象所属的类时，可以引用调用者类中定义的，不包含函数式接口第一个参数的方法，并用类::实例方法这种形式来表达，比如这样： 1234567891011121314151617181920212223242526272829303132public interface ImTheOne&lt;T&gt; &#123; String handleString(T a, String b);&#125;class OneClass &#123; String oneString; public String concatString(String a) &#123; return this.oneString + a; &#125; public String startHandleString(ImTheOne&lt;OneClass&gt; imTheOne, String str) &#123; String result = imTheOne.handleString(this, str); return result; &#125;&#125; public class Test &#123; public static void main(String[] args) &#123; OneClass oneClass = new OneClass(); oneClass.oneString = &quot;abc&quot;; String result = oneClass.startHandleString(OneClass::concatString, &quot;123&quot;); System.out.println(result); //相当于以下效果 OneClass oneClass2 = new OneClass(); oneClass2.oneString = &quot;abc&quot;; ImTheOne theOne2 = (a, b) -&gt; oneClass2.concatString(b); String result2 = theOne2.handleString(theOne2, &quot;123&quot;); System.out.println(result2); &#125;&#125; 四、构造器引用，Class::new这种模式被称为构造方法引用，或构造器引用。 构造方法也是方法，构造方法引用实际上表示一个函数式接口中的唯一方法引用了一个类的构造方法，引用的是那个参数相同的构造方法。 12345678910111213141516171819202122232425public class Lambda &#123; public static void main(String args[])&#123; GreetingService greetService1 = SayMessage::new; SayMessage sayMessage = greetService1.sayMessage(&quot;world&quot;); System.out.println(sayMessage.mes); //相当于以下效果，直接把类的静态方法写在Lambda体里 GreetingService greetService2 =mes -&gt;new SayMessage(mes); SayMessage sayMessage1 = greetService2.sayMessage(&quot;hello&quot;); System.out.println(sayMessage.mes); &#125;&#125;interface GreetingService &#123; SayMessage sayMessage(String message);&#125;class SayMessage&#123; String mes; public SayMessage(String mes) &#123; this.mes=mes; &#125; public SayMessage() &#123; this.mes=&quot;default&quot;; &#125;&#125; 五，数组引用，数组::new数组引用算是构造器引用的一种，可以引用一个数组的构造 12345678910public interface ImTheOne&lt;T&gt; &#123; T getArr(int a);&#125;public class Test &#123; public static void main(String[] args) &#123; ImTheOne&lt;int[]&gt; imTheOne = int[]::new; int[] stringArr = imTheOne.getArr(5); System.out.println(stringArr.length); &#125;&#125; 注意： 使用数组引用时，函数式接口中抽象方法必须是有参数的，而且参数只能有一个，必须是数字类型int或Integer，这个参数代表的是将来生成数组的长度。 三、默认方法Java 8 新增了接口的默认方法。 简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。 我们只需在方法名前面加个 default 关键字即可实现默认方法。 12345public interface Vehicle &#123; default void print()&#123; System.out.println(&quot;我是一辆车!&quot;); &#125;&#125; Java 8 的另一个特性是接口可以声明（并且可以提供实现）静态方法。例如： 123456789public interface Vehicle &#123; default void print()&#123; System.out.println(&quot;我是一辆车!&quot;); &#125; // 静态方法 static void blowHorn()&#123; System.out.println(&quot;按喇叭!!!&quot;); &#125;&#125; 四、StreamStream 是用函数式编程方式在集合类上进行复杂操作的工具，其集成了Java 8中的众多新特性之一的聚合操作，开发者可以更容易地使用Lambda表达式，并且更方便地实现对集合的查找、遍历、过滤以及常见计算等。 两个基础的特征： Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluentstyle）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。 内部迭代： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。 备注：“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。 当使用一个流的时候，通常包括三个基本步骤： 获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道。 Stream操作1、获取流：根据Collection获取流 1234List&lt;String&gt; list = new ArrayList&lt;&gt;();Stream&lt;String&gt; stream1 = list.stream();Set&lt;String&gt; set = new HashSet&lt;&gt;();Stream&lt;String&gt; stream2 = set.stream(); 根据Map获取流 123Stream&lt;String&gt; keyStream = map.keySet().stream();Stream&lt;String&gt; valueStream = map.values().stream();Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream(); 据数组获取流 12String[] array = &#123; &quot;张无忌&quot;, &quot;张翠山&quot;, &quot;张三丰&quot;, &quot;张一元&quot; &#125;;Stream&lt;String&gt; stream = Stream.of(array); 2、Stream中的常用方法 方法名 作用 类型 是否支持链式调用 count 统计 终结 N foreach 遍历 终结 N filter 过滤 拼接 Y limit 前n个 拼接 Y skip 跳过n个 拼接 Y map 转换/映射 拼接 Y concat 组合 拼接 Y forEach：逐一处理 1void forEach(Consumer&lt;? super T&gt; action); 该方法接收一个 Consumer 接口函数，会将每一个流元素交给该函数进行处理。 12345private static void forEachDemo()&#123; String[] array = &#123; &quot;张无忌&quot;, &quot;张翠山&quot;, &quot;张三丰&quot;, &quot;张一元&quot; &#125;; Stream&lt;String&gt; stream = Stream.of(array); stream.forEach(s -&gt; System.out.println(s));&#125; filter：过滤 1Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate); 该接口接收一个 Predicate 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。 123456private static void filterDemo()&#123; String[] array = &#123; &quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot; &#125;; Stream&lt;String&gt; stream = Stream.of(array); Stream&lt;String&gt; result = stream.filter(s -&gt; s.startsWith(&quot;张&quot;)); result.forEach(s -&gt; System.out.println(s));&#125; map： 映射 如果需要将流中的元素映射到另一个流中，可以使用 map 方法。 1&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 该接口需要一个 Function 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。 123456private static void mapDemo()&#123; String[] array = &#123;&quot;10&quot;, &quot;12&quot;, &quot;18&quot;&#125;; Stream&lt;String&gt; stringStream = Stream.of(array); Stream&lt;Integer&gt; integerStream = stringStream.map(s -&gt; Integer.parseInt(s)); integerStream.forEach(integer -&gt; System.out.println(integer)); &#125; count：统计流中的元素个数 正如旧集合 Collection 当中的 size 方法一样，流提供 count 方法来数一数其中的元素个数： 1long count(); 该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。 123456private static void countDemo()&#123; String[] array = &#123; &quot;张无忌&quot;, &quot;张翠山&quot;, &quot;张三丰&quot;, &quot;张一元&quot; &#125;; Stream&lt;String&gt; stream = Stream.of(array); long num = stream.count(); System.out.println(num);&#125; limit：取用前几个 limit 方法可以对流进行截取，只取用前n个。 1Stream&lt;T&gt; limit(long maxSize); 参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。 123456private static void limitDemo()&#123; String[] array = &#123; &quot;张无忌&quot;, &quot;张翠山&quot;, &quot;张三丰&quot;, &quot;张一元&quot; &#125;; Stream&lt;String&gt; stream = Stream.of(array); Stream&lt;String&gt; newStream = stream.limit(3); newStream.forEach(s -&gt; System.out.println(s));&#125; skip：跳过前几个 如果希望跳过前几个元素，可以使用 skip 方法获取一个截取之后的新流： 1Stream&lt;T&gt; skip(long n); 如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。n必须大于等于0，如果大于当前流中的元素个数，则产生一个空流。 123456private static void skipDemo()&#123; String[] array = &#123; &quot;张无忌&quot;, &quot;张翠山&quot;, &quot;张三丰&quot;, &quot;张一元&quot; &#125;; Stream&lt;String&gt; stream = Stream.of(array); Stream&lt;String&gt; newStream = stream.skip(2); newStream.forEach(s -&gt; System.out.println(s));&#125; concat：组合 如果有两个流，希望合并成为一个流，那么可以使用 Stream 接口的静态方法 concat ： 1static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) 例子： 123456private static void concatDemo()&#123; Stream&lt;String&gt; stream1 = Stream.of(&quot;张三&quot;); Stream&lt;String&gt; stream2 = Stream.of(&quot;李四&quot;); Stream&lt;String&gt; stream = Stream.concat(stream1,stream2); stream.forEach(s -&gt; System.out.println(s));&#125; sorted：排序 1Stream&lt;T&gt; sorted() sorted 方法用于对流进行排序。 12345private static void sortedDemo()&#123; String[] array = &#123; &quot;张无忌&quot;, &quot;张翠山&quot;, &quot;张三丰&quot;, &quot;张一元&quot; &#125;; Stream&lt;String&gt; stream = Stream.of(array); stream.limit(3).sorted().forEach(System.out::println);&#125; 元素收集 1）收集到List集合： 1流对象.collect( Collectors.toList() ) 获得List集合。 2）收集到Set集合： 1流对象.collect( Collectors.toSet() ) 获得Set集合。 3）收集到数组： 1流对象. toArray() 由于泛型擦除的原因，返回值类型是Object[] 查找 1allMatch(Predicate&lt;? super T&gt; predicate) 用于检测是否全部都满足指定的参数行为，如果全部满足则返回true 1anyMatch(Predicate&lt;? super T&gt; predicate) anyMatch则是检测是否存在一个或多个满足指定的参数行为，如果满足则返回true 1noneMatch(Predicate&lt;? super T&gt; predicate) oneMatch用于检测是否不存在满足指定行为的元素，如果不存在则返回true 1findFirst() findFirst用于返回满足条件的第一个元素 1findAny() findAny相对于findFirst的区别在于，findAny不一定返回第一个，而是返回任意一个 123456789private static void findDemo()&#123; List&lt;String&gt; items = Arrays.asList(&quot;apple&quot;, &quot;apple&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;, &quot;papaya&quot;); Stream&lt;String&gt; stream = items.stream(); System.out.println(stream.allMatch(s -&gt; s.contains(&quot;a&quot;))); Stream&lt;String&gt; stream1 = items.stream(); System.out.println(stream1.filter(s -&gt; s.contains(&quot;a&quot;)).findFirst().get()); Stream&lt;String&gt; stream2 = items.stream(); System.out.println(stream2.filter(s -&gt; s.contains(&quot;a&quot;)).findAny().get()); &#125; 字符串拼接 1public static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter) 参数为连接符，返回值为一个集合。 12345678910private static void joinDemo()&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;张无忌&quot;); list.add(&quot;周芷若&quot;); list.add(&quot;赵敏&quot;); list.add(&quot;张强&quot;); list.add(&quot;张三丰&quot;); System.out.println(list); System.out.println(list.stream().collect(Collectors.joining(&quot;,&quot;))); &#125; 去重 1Stream&lt;T&gt; distinct(); 例子; 12345private static void distinctDemo()&#123; List&lt;String&gt; items = Arrays.asList(&quot;apple&quot;, &quot;apple&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;, &quot;papaya&quot;); Stream stream = items.stream().distinct(); stream.forEach(System.out::println); &#125; 五、 日期时间 APIJava 8 在 java.time 包下提供了很多新的 API。以下为两个比较重要的 API： Local(本地) − 简化了日期时间的处理，没有时区的问题。 Zoned(时区) − 通过制定的时区处理日期时间。 本地化日期时间 APILocalDate/LocalTime 和 LocalDateTime 类可以在处理时区不是必须的情况。代码如下： 123456789101112131415161718192021222324252627// 获取当前的日期时间 LocalDateTime currentTime = LocalDateTime.now(); System.out.println(&quot;当前时间: &quot; + currentTime); LocalDate date1 = currentTime.toLocalDate(); System.out.println(&quot;date1: &quot; + date1); Month month = currentTime.getMonth(); int day = currentTime.getDayOfMonth(); int seconds = currentTime.getSecond(); System.out.println(&quot;月: &quot; + month +&quot;, 日: &quot; + day +&quot;, 秒: &quot; + seconds); LocalDateTime date2 = currentTime.withDayOfMonth(10).withYear(2012); System.out.println(&quot;date2: &quot; + date2); // 12 december 2014 LocalDate date3 = LocalDate.of(2014, Month.DECEMBER, 12); System.out.println(&quot;date3: &quot; + date3); // 22 小时 15 分钟 LocalTime date4 = LocalTime.of(22, 15); System.out.println(&quot;date4: &quot; + date4); // 解析字符串 LocalTime date5 = LocalTime.parse(&quot;20:15:30&quot;); System.out.println(&quot;date5: &quot; + date5); 执行结果： 1234567当前时间: 2016-04-15T16:55:48.668date1: 2016-04-15月: APRIL, 日: 15, 秒: 48date2: 2012-04-10T16:55:48.668date3: 2014-12-12date4: 22:15date5: 20:15:30 使用时区的日期时间API如果我们需要考虑到时区，就可以使用时区的日期时间API： 123456789// 获取当前时间日期ZonedDateTime date1 = ZonedDateTime.parse(&quot;2015-12-03T10:15:30+05:30[Asia/Shanghai]&quot;);System.out.println(&quot;date1: &quot; + date1); ZoneId id = ZoneId.of(&quot;Europe/Paris&quot;);System.out.println(&quot;ZoneId: &quot; + id); ZoneId currentZone = ZoneId.systemDefault();System.out.println(&quot;当期时区: &quot; + currentZone); 执行结果： 123date1: 2015-12-03T10:15:30+08:00[Asia/Shanghai]ZoneId: Europe/Paris当期时区: Asia/Shanghai 六、Base64Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法 特点 可以将任意的二进制数据进行Base64编码。 数据加密之后，数据量会变大，变大1/3左右。 编码后有个非常显著的特点，末尾有个=号。 可进行反向解密。 Base64编码具有不可读性 在Java 8中，Base64编码已经成为Java类库的标准。 Java 8 内置了 Base64 编码的编码器和解码器。 Base64工具类提供了一套静态方法获取下面三种BASE64编解码器： 基本：输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/。 URL：输出映射到一组字符A-Za-z0-9+_，输出是URL和文件。 MIME：输出隐射到MIME友好格式。输出每行不超过76字符，并且使用’\\r’并跟随’\\n’作为分割。编码输出最后没有行分割。 内嵌类 序号 方法名 &amp; 描述 1 **static Base64.Decoder getDecoder()**返回一个 Base64.Decoder ，解码使用基本型 base64 编码方案。 2 **static Base64.Encoder getEncoder()**返回一个 Base64.Encoder ，编码使用基本型 base64 编码方案。 3 **static Base64.Decoder getMimeDecoder()**返回一个 Base64.Decoder ，解码使用 MIME 型 base64 编码方案。 4 **static Base64.Encoder getMimeEncoder()**返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案。 5 **static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator)**返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案，可以通过参数指定每行的长度及行的分隔符。 6 **static Base64.Decoder getUrlDecoder()**返回一个 Base64.Decoder ，解码使用 URL 和文件名安全型 base64 编码方案。 7 **static Base64.Encoder getUrlEncoder()**返回一个 Base64.Encoder ，编码使用 URL 和文件名安全型 base64 编码方案。 123456789101112131415161718192021222324252627public static void main(String args[]) &#123; try &#123; // 使用基本编码 String base64encodedString = Base64.getEncoder().encodeToString(&quot;this is a test&quot;.getBytes(&quot;utf-8&quot;)); System.out.println(&quot;Base64 编码字符串 (基本) :&quot; + base64encodedString); // 解码 byte[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString); System.out.println(&quot;原始字符串: &quot; + new String(base64decodedBytes, &quot;utf-8&quot;)); base64encodedString = Base64.getUrlEncoder().encodeToString(&quot;this is a test&quot;.getBytes(&quot;utf-8&quot;)); System.out.println(&quot;Base64 编码字符串 (URL) :&quot; + base64encodedString); StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; 10; ++i) &#123; stringBuilder.append(UUID.randomUUID().toString()); &#125; byte[] mimeBytes = stringBuilder.toString().getBytes(&quot;utf-8&quot;); String mimeEncodedString = Base64.getMimeEncoder().encodeToString(mimeBytes); System.out.println(&quot;Base64 编码字符串 (MIME) :&quot; + mimeEncodedString); &#125;catch(UnsupportedEncodingException e)&#123; System.out.println(&quot;Error :&quot; + e.getMessage()); &#125; &#125; 执行结果： 12345678910Base64 编码字符串 (基本) :dGhpcyBpcyBhIHRlc3Q=原始字符串: this is a testBase64 编码字符串 (URL) :dGhpcyBpcyBhIHRlc3Q=Base64 编码字符串 (MIME) :Zjc0MzI1YTYtNjczMC00MGY5LWJmN2ItMjUxZDBkMTNjOTdlN2UxOTliMTYtNmVjYS00NjJjLTk5YWQtZjZkODc3NDJkMzgwNWE0OWM5OWMtYmRlZC00ZTY4LThkYjQtMmZiZjBjNTA2ZWMxNGY2MWI1ODctZGE3MC00NGU4LWEyNDQtZWFlMDdjM2NjNGFiMmI0NDQ0OTktODg5YS00MTA5LWFjZTYtYzViNTBiM2YyZDJkMzZmMWE2NGQtMGQ4Ni00MGJkLWJlZDEtOWE1NTA3ZWFjM2QxYTZjNGMzYWMtMjJiNi00ZTBlLTg0M2MtN2Q2Yzg0NTBmZDRhMGZlNjIxN2EtMTJmYS00MGM4LTgzOTEtMTlkZGRlMzljYzhmZGJhMDI5NDAtODI2NC00OGQ1LTlhYmUtMjRhMWM3NDI3YzZiMzU2ODY1YjYtZjJkNi00ZGNlLWJkMzYtYTIyNmFmOTNmOGM2","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"jdk8新特性","slug":"java/jdk8新特性","permalink":"http://example.com/categories/java/jdk8%E6%96%B0%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"zookeeper","slug":"zookeeper","date":"2021-11-23T09:08:59.000Z","updated":"2021-11-23T17:08:02.531Z","comments":true,"path":"2021/11/23/zookeeper/","link":"","permalink":"http://example.com/2021/11/23/zookeeper/","excerpt":"","text":"一、ZoomKeeper简介 ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 ​ zookeeper=文件系统+监听通知机制 二、内部原理1、选举机制为什么要进行Leader选举？Leader主要作用是保证分布式数据一致性，即每个节点的存储的数据同步。遇到以下两种情况需要进行Leader选举： 服务器初始化启动 服务器运行期间无法和Leader保持连接，Leader节点崩溃，逻辑时钟崩溃。 zookeeper提供了三种选举算法,默认的算法是 FastLeaderElection ,简单点就是投票数大于半数则胜出： LeaderElection AuthFastLeaderElection FastLeaderElection (default) 概念myid (服务器ID) state (当前服务器的状态) LOOKING : 竞选状态。 FOLLOWING : 随从状态，同步leader状态，参与投票。 OBSERVING : 观察状态，同步leader状态，不参与投票。 LEADING : 领导者状态。 zxid (事务ID) 被推举的Leader事务ID，服务器中存放的最新数据version，值越大说明数据越新，在选举中数据越新权重越大。 electionEpoch (逻辑时钟) 逻辑时钟，用来判断多个投票是否在同一轮选举周期中，该值在服务端是一个自增序列，每次进入新一轮的投票后，都会对该值进行加1操作。 peerEpoch 被推举的Leader的epoch。 选举机制（半数机制） 投票下处理规则 首先对比zxid。zxid大的服务器优先作为Leader 若zxid相同，比如初始化的时候，每个Server的zxid都为0，就会比较myid，myid大的选出来做Leader。 服务器初始化时选举 目前有3台服务器，每台服务器均没有数据，它们的编号分别是1,2,3按编号依次启动，它们的选择举过程如下： Server1启动，给自己投票（1,0），然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，Server1的状态一直属于Looking。 Server2启动，给自己投票（2,0），同时与之前启动的Server1交换结果，由于Server2的编号大所以Server2胜出，但此时投票数正好大于半数，所以Server2成为领导者，Server1成为小弟。 Server3启动，给自己投票（3,0），同时与之前启动的Server1,Server2换信息，尽管Server3的编号大，但之前Server2已经胜出，所以Server3只能成为小弟。 当确定了Leader之后，每个Server更新自己的状态，Leader将状态更新为Leading，Follower将状态更新为Following。 服务器运行期间的选举 zookeeper运行期间，如果有新的Server加入，或者非Leader的Server宕机，那么Leader将会同步数据到新Server或者寻找其他备用Server替代宕机的Server。若Leader宕机，此时集群暂停对外服务，开始在内部选举新的Leader。假设当前集群中有Server1、Server2、Server3三台服务器，Server2为当前集群的Leader，由于意外情况，Server2宕机了，便开始进入选举状态。过程如下： 变更状态。其他的非Observer服务器将自己的状态改变为Looking，开始进入Leader选举。 每个Server发出一个投票（myid，zxid），由于此集群已经运行过，所以每个Server上的zxid可能不同。假设Server1的zxid为100，Server3的为99，第一轮投票中，Server1和Server3都投自己，票分别为（1，100）,（3,99）,将自己的票发送给集群中所有机器。 每个Server接收接收来自其他Server的投票，接下来的步骤与启动时步骤相同。 2、paxos算法​ Paxos用于解决分布式系统中一致性问题。分布式一致性算法（Consensus Algorithm）是一个分布式计算领域的基础性问题，其最基本的功能是为了在多个进程之间对某个（某些）值达成一致（强一致）；简单来说就是确定一个值，一旦被写入就不可改变。 三、安装与配置下载地址：http://archive.apache.org/dist/zookeeper/ 12345678910111213[root@localhost ~]# mkdir -p /usr/local/zookeeper[root@localhost ~]# tar -zxvf zookeeper-3.4.13.tar.gz -C /usr/local/zookeeper/[root@localhost ~]# cd /usr/local/zookeeper/zookeeper-3.4.13/[root@localhost zookeeper-3.4.13]# cd conf[root@localhost conf]# cp zoo_sample.cfg zoo.cfg //启动会找zoo.cfg[root@localhost zookeeper-3.4.13]# mkdir data[root@localhost zookeeper-3.4.13]# mkdir log[root@localhost zookeeper-3.4.13]# cd conf[root@localhost conf]# vim zoo.cfg//修改dataDir=/usr/local/zookeeper/zookeeper-3.4.13/datalogDir=/usr/local/zookeeper/zookeeper-3.4.13/log//:wq 保存并退出 四、启动12345678[root@localhost conf]# cd ..[root@localhost zookeeper-3.4.13]# cd bin/[root@localhost bin]# ./zkServer.sh start //启动[root@localhost bin]# ./zkServer.sh status //查看状态ZooKeeper JMX enabled by defaultUsing config: /usr/local/zookeeper/zookeeper-3.4.13/bin/../conf/zoo.cfgMode: standalone //单节点 五、停止1[root@localhost bin]# ./zkServer.sh stop","categories":[{"name":"zookeeper","slug":"zookeeper","permalink":"http://example.com/categories/zookeeper/"}],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"http://example.com/tags/zookeeper/"}]},{"title":"dubbo","slug":"dubbo","date":"2021-11-23T09:07:58.000Z","updated":"2021-11-23T17:06:43.625Z","comments":true,"path":"2021/11/23/dubbo/","link":"","permalink":"http://example.com/2021/11/23/dubbo/","excerpt":"","text":"一、Dubbo简介Dubbo是Alibaba开源的分布式服务框架，它最大的特点是按照分业务的架构，使用这种方式可以使各个业务之间解耦合（或者最大限度地松耦合）。 *简单来说Dubbo:* 一款分布式服务框架 高性能和透明化的RPC远程服务调用方案 SOA服务治理方案 名词概念 Provider: 暴露服务的服务提供方。Consumer: 调用远程服务的服务消费方。Registry: 服务注册与发现的注册中心。Monitor: 统计服务的调用次数和调用时间的监控中心。 *调用流程* 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 二、SpringBoot整合Dubbo1、三个工程： 接口工程：存放实体bean和业务接口 服务提供者：业务接口的实现类，同时将服务暴露，注册到注册中心zookeeper，调用数据持久层（dao） pom文件中添加依赖（dubbo、注册中心zookeeper、接口工程） 配置服务提供者的dubbo核心配置文件application.yml 服务消费者：处理浏览器客户端发来的请求，从注册中心调用服务提供者所提供的服务。 pom文件中添加依赖（dubbo、注册中心zookeeper、接口工程） 配置服务消费者的dubbo核心配置文件application.yml 2、父工程2.1pom.xml12345678910111213141516171819&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;dubbo.version&gt;2.0.0&lt;/dubbo.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.101tec/zkclient --&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.11&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 3、接口工程：123public interface UserServiceI &#123; User selectUserById(Integer id) throws RemoteException;&#125; pom.xml 123456789101112131415&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.101tec/zkclient --&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 4、服务提供者4.1、application.yml123456789101112131415server: port: 8801spring: application: name: dubbo dubbo: server: true application: name: provider registry: address: zookeeper://192.168.159.180:2181 protocol: name: dubbo port: 20880 scan: com.mjx.provider.service 4.2、pom.xml123456789101112131415&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.mjx&lt;/groupId&gt; &lt;artifactId&gt;dubbo-api&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 4.3、接口实现类123456789101112@Service(interfaceClass = UserServiceI.class)@Componentpublic class UserServiceImpl implements UserServiceI &#123; @Override public User selectUserById(Integer id) throws RemoteException &#123; User user=new User(); user.setId(id); user.setUsername(&quot;张三&quot;); System.out.println(&quot;提供服务,接收到客户端的用户id为:&quot;+id); return user; &#125;&#125; @Component注解表示将该实现类加载到Spring容器中 @Service注解（这个注解和Spring下的@Service注解不一样，它是dubbo下属的直接）interface指的是暴露接口服务 4.4 、启动类1234567@SpringBootApplication@EnableDubboConfiguration //开启dubbopublic class DubboProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DubboProviderApplication.class,args); &#125;&#125; 5、服务消费者5.1、application.xml1234567891011121314server: port: 8802spring: application: name: dubbo dubbo: application: name: consumer registry: address: zookeeper://192.168.159.180:2181 protocol: name: dubbo port: 20880 scan: com.mjx.consumer 5.2、pom.xml123456789101112131415&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.mjx&lt;/groupId&gt; &lt;artifactId&gt;dubbo-api&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 5.3、消费服务12345678910@Componentpublic class UserInit implements CommandLineRunner &#123; @Reference(interfaceClass = UserServiceI.class) private UserServiceI userService; @Override public void run(String... args) throws Exception &#123; System.out.println(userService.selectUserById(2)); &#125;&#125; 5.4、启动类1234567@SpringBootApplication@EnableDubboConfigurationpublic class DubboConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DubboConsumerApplication.class,args); &#125;&#125; 三、Dubbo-admin的安装12345678910[root@localhost ~]# yum -y install unzip //解压war包工具[root@localhost webapps]# rm -rf ROOT[root@localhost webapps]# mkdir ROOT[root@localhost ~]# unzip dubbo-admin-2.6.0.war -d /home/software/apache-tomcat-9.0.54/webapps/ROOT[root@localhost ~]# cd /home/software/apache-tomcat-9.0.54/webapps/ROOT/WEB-INF/[root@localhost WEB-INF]# vim dubbo.properties//修改dubbo.registry.address=zookeeper://192.168.159.180:2181//回到bin目录启动tomcat[root@localhost bin]# ./startup.sh","categories":[{"name":"dubbo","slug":"dubbo","permalink":"http://example.com/categories/dubbo/"}],"tags":[{"name":"dubbo","slug":"dubbo","permalink":"http://example.com/tags/dubbo/"}]},{"title":"springsecurity的使用","slug":"springsecurity","date":"2021-11-22T05:07:08.000Z","updated":"2021-11-22T13:10:07.844Z","comments":true,"path":"2021/11/22/springsecurity/","link":"","permalink":"http://example.com/2021/11/22/springsecurity/","excerpt":"","text":"1、密码解析器1234567//加密PasswordEncoder pe=new BCryptPasswordEncoder();String encode = pe.encode(&quot;123&quot;);System.out.println(encode);//是否匹配boolean matches = pe.matches(&quot;123&quot;, encode);System.out.println(matches); 2、自定义登录逻辑1、必须注入PasswordEncoder 1234567@Configurationpublic class SecurityConfig &#123; @Bean public PasswordEncoder getPw()&#123; return new BCryptPasswordEncoder(); &#125;&#125; 2、实现UserDetailsService接口 1234567891011121314@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private PasswordEncoder pe; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; //数据库查询用户名是否存在，不存在抛出UsernameNotFoundException if (!&quot;admin&quot;.equals(username))&#123; throw new UsernameNotFoundException(&quot;用户名不存在&quot;); &#125; String password = pe.encode(&quot;123&quot;); return new User(username,password, AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin,normal&quot;)); &#125;&#125; 3、修改登录页面修改配置类 123456789101112131415161718192021222324252627@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; //表单提交 http.formLogin() //根据url为/login的执行登录逻辑 .loginProcessingUrl(&quot;/login&quot;) //自定义登录页面 .loginPage(&quot;/login.html&quot;) //登录成功页面，post请求 .successForwardUrl(&quot;/toMain&quot;); //授权认证 http.authorizeRequests() //不需要被认证 .antMatchers(&quot;/login.html&quot;).permitAll() //所有请求必须经过认证，登录后才能访问 .anyRequest().authenticated(); //关闭csrf保护 http.csrf().disable(); &#125; @Bean public PasswordEncoder getPw()&#123; return new BCryptPasswordEncoder(); &#125;&#125; 12345678@Controllerpublic class LoginController &#123; @RequestMapping(&quot;toMain&quot;) public String toMain()&#123; System.out.println(&quot;执行登录&quot;); return &quot;redirect:main.html&quot;; &#125;&#125; 4、失败跳转 123456789101112131415161718192021222324252627282930313233@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; //表单提交 http.formLogin() //根据url为/login的执行登录逻辑 .loginProcessingUrl(&quot;/login&quot;) //自定义登录页面 .loginPage(&quot;/login.html&quot;) //登录成功页面，post请求 .successForwardUrl(&quot;/toMain&quot;) //登录失败后跳转页面,post请求 .failureForwardUrl(&quot;/toError&quot;); //授权认证 http.authorizeRequests() //不需要被认证 .antMatchers(&quot;/error.html&quot;).permitAll() .antMatchers(&quot;/login.html&quot;).permitAll() //所有请求必须经过认证，登录后才能访问 //regexMatchers :正则匹配 //.regexMatchers(HttpMethod.POST,&quot;/demo&quot;).permitAll(); //.mvcMatchers(&quot;/demo&quot;).servletPath(&quot;/xxxx&quot;).permitAll() .anyRequest().authenticated(); //关闭csrf保护 http.csrf().disable(); &#125; @Bean public PasswordEncoder getPw()&#123; return new BCryptPasswordEncoder(); &#125;&#125; 12345@RequestMapping(&quot;toError&quot;) public String toError()&#123; System.out.println(&quot;执行登录&quot;); return &quot;redirect:error.html&quot;; &#125; 4、登录成功跳转到外站1234567891011121314151617public class MyAuthenticationSuccessHandler implements AuthenticationSuccessHandler &#123; private String url; public MyAuthenticationSuccessHandler(String url) &#123; this.url = url; &#125; @Override public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException &#123; User user = (User) authentication.getPrincipal(); System.out.println(user.getUsername()); System.out.println(user.getAuthorities()); //null System.out.println(user.getPassword()); httpServletResponse.sendRedirect(url); &#125;&#125; 123456789101112131415161718192021222324252627282930313233@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; //表单提交 http.formLogin() //根据url为/login的执行登录逻辑 .loginProcessingUrl(&quot;/login&quot;) //自定义登录页面 .loginPage(&quot;/login.html&quot;) //登录成功页面，post请求 //.successForwardUrl(&quot;/toMain&quot;) //登录成功跳转到外站 .successHandler(new MyAuthenticationSuccessHandler(&quot;http://www.baidu.com&quot;)) //登录失败后跳转页面,post请求 .failureForwardUrl(&quot;/toError&quot;); //授权认证 http.authorizeRequests() //不需要被认证 .antMatchers(&quot;/error.html&quot;).permitAll() .antMatchers(&quot;/login.html&quot;).permitAll() //所有请求必须经过认证，登录后才能访问 .anyRequest().authenticated(); //关闭csrf保护 http.csrf().disable(); &#125; @Bean public PasswordEncoder getPw()&#123; return new BCryptPasswordEncoder(); &#125;&#125; 4、匹配方式12345678http.authorizeRequests() //不需要被认证 .antMatchers(&quot;/error.html&quot;).permitAll() .antMatchers(&quot;/login.html&quot;).permitAll() //.regexMatchers(HttpMethod.POST,&quot;/demo&quot;).permitAll(); //.mvcMatchers(&quot;/demo&quot;).servletPath(&quot;/xxxx&quot;).permitAll() //所有请求必须经过认证，登录后才能访问 .anyRequest().authenticated(); 5、内置访问控制12345permitAllanonymousauthenticatedfullyAuthenticatedrememberMe 6、权限判断123//权限判断//.antMatchers(&quot;/main1.html&quot;).hasAuthority(&quot;admin&quot;) .antMatchers(&quot;/main1.html&quot;).hasAnyAuthority(&quot;ADMIN&quot;,&quot;admin&quot;) 7、角色判断添加角色 123//添加角色 ROLE_角色名 return new User(username,password, AuthorityUtils. commaSeparatedStringToAuthorityList(&quot;admin,normal,ROLE_abc&quot;)); 123//角色判断//.antMatchers(&quot;/main.html&quot;).hasRole(&quot;abc&quot;) .antMatchers(&quot;/main.html&quot;).hasAnyRole(&quot;abc&quot;) 8、IP地址判断12//ip判断.antMatchers(&quot;/main1.html&quot;).hasIpAddress(&quot;127.0.0.1&quot;) 9、自定义403页面实现AccessDeniedHandler 12345678910111213@Componentpublic class MyAccessDeniedHandler implements AccessDeniedHandler &#123; @Override public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException &#123; //响应状态码 httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN); httpServletResponse.setHeader(&quot;Content-Type&quot;,&quot;application/json;charset=utf-8&quot;); PrintWriter writer = httpServletResponse.getWriter(); writer.write(&quot;&#123;\\&quot;status\\&quot;:\\&quot;error\\&quot;,\\&quot;msg\\&quot;:\\&quot;权限不足，请联系管理员\\&quot;&#125;&quot;); writer.flush(); writer.close(); &#125;&#125; 1234567891011@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private MyAccessDeniedHandler myAccessDeniedHandler; @Override protected void configure(HttpSecurity http) throws Exception &#123; //异常处理 http.exceptionHandling() .accessDeniedHandler(myAccessDeniedHandler); &#125;&#125; 10、access（）表达式12.antMatchers(&quot;/login.html&quot;).access(&quot;permitAll()&quot;).antMatchers(&quot;/main.html&quot;).access(&quot;hasRole(&#x27;abc&#x27;)&quot;) 11、access（）结合自定义方法实现权限控制123456789101112@Servicepublic class MyServiceImpl implements MyService &#123; @Override public boolean hasPermission(HttpServletRequest request, Authentication authentication) &#123; Object obj = authentication.getPrincipal(); if (obj instanceof UserDetails) &#123; UserDetails userDetails= (UserDetails) obj; Collection&lt;? extends GrantedAuthority&gt; authorities = userDetails.getAuthorities(); authorities.contains(new SimpleGrantedAuthority(request.getRequestURI())); &#125; return false; &#125; 12return new User(username,password, AuthorityUtils. commaSeparatedStringToAuthorityList(&quot;admin,normal,ROLE_abc,/main.html&quot;)); 1.anyRequest().access(&quot;@myServiceImpl.hasPermission(request,authentication)&quot;); 12、基于注解的访问控制@Secured判断是否具有角色 启动类添加 1@EnableGlobalMethodSecurity(securedEnabled = true) 123456@Secured(&quot;ROLE_abc&quot;) @RequestMapping(&quot;toMain&quot;) public String toMain()&#123; System.out.println(&quot;执行登录&quot;); return &quot;redirect:main.html&quot;; &#125; @PreAuthorize/@PostAuthorizePreAuthorize:访问方法或类在执行之前先判断权限 PostAuthorize：访问方法或类在执行之后判断权限 启动类添加 1@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true) 123456@PreAuthorize(&quot;hasRole(&#x27;abc&#x27;)&quot;) @RequestMapping(&quot;toMain&quot;) public String toMain()&#123; System.out.println(&quot;执行登录&quot;); return &quot;redirect:main.html&quot;; &#125; 13、记住我功能12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.18&lt;/version&gt;&lt;/dependency&gt; 1234spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/security?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=GMTspring.datasource.username=rootspring.datasource.password=root 123456789101112131415161718192021222324252627282930@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private UserDetailsServiceImpl userDetailsService; @Autowired private DataSource dataSource; @Autowired private PersistentTokenRepository persistentTokenRepository; @Override protected void configure(HttpSecurity http) throws Exception //记住我功能 http.rememberMe() //设置失效时间 .tokenValiditySeconds(60) //.rememberMeParameter() //自定义登录逻辑 .userDetailsService(userDetailsService) //持久层对象 .tokenRepository(persistentTokenRepository); &#125; @Bean public PersistentTokenRepository getPersistentTokenRepository()&#123; JdbcTokenRepositoryImpl jdbcTokenRepository=new JdbcTokenRepositoryImpl(); jdbcTokenRepository.setDataSource(dataSource); //自动建表，第一次启动需要，以后需注释 jdbcTokenRepository.setCreateTableOnStartup(true); return jdbcTokenRepository; &#125;&#125; 1记住我：&lt;input type=&quot;checkbox&quot; name=&quot;remember-me&quot; value=&quot;true&quot;&gt; 14、thymeleaf中SpringSecurity的使用12345678&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 1234@RequestMapping(&quot;demo&quot;) public String demo()&#123; return &quot;demo&quot;; &#125; 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot; &gt;&lt;head&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;登录账号：&lt;span sec:authentication=&quot;name&quot;&gt;&lt;/span&gt;&lt;br&gt;登录账号：&lt;span sec:authentication=&quot;principal.username&quot;&gt;&lt;/span&gt;&lt;br&gt;凭证：&lt;span sec:authentication=&quot;credentials&quot;&gt;&lt;/span&gt;&lt;br&gt;权限和角色：&lt;span sec:authentication=&quot;authorities&quot;&gt;&lt;/span&gt;&lt;br&gt;客户端地址：&lt;span sec:authentication=&quot;details.remoteAddress&quot;&gt;&lt;/span&gt;&lt;br&gt;sessionId：&lt;span sec:authentication=&quot;details.sessionId&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt; 123456登录账号：admin登录账号：admin凭证：权限和角色：[/main.html, ROLE_abc, admin, normal]客户端地址：0:0:0:0:0:0:0:1sessionId：5B0D90627080C26C78900EEB010F657C 14、thymeleaf权限判断12345678910通过权限判断&lt;button sec:authorize=&quot;hasAuthority(&#x27;/insert&#x27;)&quot;&gt;新增&lt;/button&gt;&lt;button sec:authorize=&quot;hasAuthority(&#x27;/delete&#x27;)&quot;&gt;删除&lt;/button&gt;&lt;button sec:authorize=&quot;hasAuthority(&#x27;/update&#x27;)&quot;&gt;修改&lt;/button&gt;&lt;button sec:authorize=&quot;hasAuthority(&#x27;/select&#x27;)&quot;&gt;查看&lt;/button&gt;通过角色判断&lt;button sec:authorize=&quot;hasRole(&#x27;abc&#x27;)&quot;&gt;新增&lt;/button&gt;&lt;button sec:authorize=&quot;hasRole(&#x27;abc&#x27;)&quot;&gt;删除&lt;/button&gt;&lt;button sec:authorize=&quot;hasRole(&#x27;abc&#x27;)&quot;&gt;修改&lt;/button&gt;&lt;button sec:authorize=&quot;hasRole(&#x27;abc&#x27;)&quot;&gt;查看&lt;/button&gt; 15、退出登录1234//退出登录 http.logout() //.logoutUrl(&quot;/user/logout&quot;) .logoutSuccessUrl(&quot;/login.html&quot;); 1&lt;a href=&quot;/logout&quot;&gt;退出登录&lt;/a&gt; 16、csrf 跨站请求伪造17、Oauth2简介：OAuth（开放授权）是一个开放标准，允许用户授权第三方移动应用访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方移动应用或分享他们数据的所有内容，OAuth2.0是OAuth协议的延续版本，但不向后兼容OAuth 1.0即完全废止了OAuth1.0。 应用场景：第三方应用授权登录：在APP或者网页接入一些第三方应用时，时长会需要用户登录另一个合作平台，比如QQ，微博，微信的授权登录。 授权模式 授权码模式（authorization code） 简化模式（implicit） 密码模式（resource owner password credentials） 客户端模式（client credentials） 授权码模式授权码模式（authorization code）是功能最完整、流程最严密的授权模式。 （1）用户访问客户端，后者将前者导向认证服务器，假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。 （2）客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌：GET /oauth/token?response_type=code&amp;client_id=test&amp;redirect_uri=重定向页面链接。请求成功返回code授权码，一般有效时间是10分钟。 （3）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。POST /oauth/token?response_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA&amp;redirect_uri=重定向页面链接。 简化模式简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。 流程步骤： （A）客户端将用户导向认证服务器。 （B）用户决定是否给于客户端授权。 （C）假设用户给予授权，认证服务器将用户导向客户端指定的”重定向URI”，并在URI的Hash部分包含了访问令牌。 （D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。 （E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。 （F）浏览器执行上一步获得的脚本，提取出令牌。 （G）浏览器将令牌发给客户端。 请求URL： 123GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1 Host: server.example.com 用户名密码模式密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下。一般不支持refresh token。 步骤说明： （A）用户向客户端提供用户名和密码。 （B）客户端将用户名和密码发给认证服务器，向后者请求令牌。 （C）认证服务器确认无误后，向客户端提供访问令牌。 12345 POST /token HTTP/1.1 Host: server.example.com Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW Content-Type: application/x-www-form-urlencodedgrant_type=password&amp;username=johndoe&amp;password=A3ddj3w 客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。 客户端模式 它的步骤如下： （A）客户端向认证服务器进行身份认证，并要求一个访问令牌。 （B）认证服务器确认无误后，向客户端提供访问令牌。 A步骤中，客户端发出的HTTP请求，包含以下参数： granttype：表示授权类型，此处的值固定为”clientcredentials”，必选项。 scope：表示权限范围，可选项。 123456POST /token HTTP/1.1Host: server.example.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=client_credentials 18、springsecurityOauth2授权码模式12345678910111213141516171819202122232425262728293031323334&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR2&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 12345678910@Servicepublic class UserService implements UserDetailsService &#123; @Autowired private PasswordEncoder pe; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; String password = pe.encode(&quot;123456&quot;); return new User(&quot;admin&quot;,password, AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admin&quot;)); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class User implements UserDetails &#123; private String username; private String password; private List&lt;GrantedAuthority&gt; authorities; public User(String username, String password, List&lt;GrantedAuthority&gt; authorities) &#123; this.username = username; this.password = password; this.authorities = authorities; &#125; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; return null; &#125; @Override public String getPassword() &#123; return null; &#125; @Override public String getUsername() &#123; return null; &#125; @Override public boolean isAccountNonExpired() &#123; return false; &#125; @Override public boolean isAccountNonLocked() &#123; return false; &#125; @Override public boolean isCredentialsNonExpired() &#123; return false; &#125; @Override public boolean isEnabled() &#123; return false; &#125;&#125; 123456789101112131415161718192021@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder getPw()&#123; return new BCryptPasswordEncoder(); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.csrf().disable() .authorizeRequests() .antMatchers(&quot;/oauth/**&quot;,&quot;/login/**&quot;,&quot;/logout/**&quot;) .permitAll() .anyRequest() .authenticated() .and() .formLogin() .permitAll(); &#125;&#125; 1234567891011121314151617181920212223@Configuration@EnableAuthorizationServerpublic class AuthorizationServiceConfig extends AuthorizationServerConfigurerAdapter &#123; @Autowired private PasswordEncoder pe; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() //配置client-id .withClient(&quot;admin&quot;) //配置client-secret .secret(pe.encode(&quot;112233&quot;)) //配置访问token的有效期 .accessTokenValiditySeconds(3600) //授权成功后跳转 .redirectUris(&quot;http://www.baidu.com&quot;) //申请的权限范围 .scopes(&quot;all&quot;) //授权类型 .authorizedGrantTypes(&quot;authorization_code&quot;); &#125;&#125; 12345678910111213@Configuration@EnableResourceServerpublic class ResourceServiceConfig extends ResourceServerConfigurerAdapter &#123; @Override public void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest() .authenticated() .and() .requestMatchers() .antMatchers(&quot;/user/**&quot;); &#125;&#125; 19、JWTjson web token 实际上是个字符串 三部分组成：头部、载荷、签名","categories":[{"name":"spring","slug":"spring","permalink":"http://example.com/categories/spring/"},{"name":"springsecurity","slug":"spring/springsecurity","permalink":"http://example.com/categories/spring/springsecurity/"}],"tags":[{"name":"springsecurity","slug":"springsecurity","permalink":"http://example.com/tags/springsecurity/"}]},{"title":"redis的使用","slug":"redis","date":"2021-11-21T23:18:08.000Z","updated":"2021-11-22T13:10:22.214Z","comments":true,"path":"2021/11/22/redis/","link":"","permalink":"http://example.com/2021/11/22/redis/","excerpt":"","text":"一、Linux下redis的安装1、下载redis.tar.gz传输至linux2、解压编译后启动服务12345678910111213141516171819202122232425262728293031[root@localhost ~]# yum -y install centos-release-scl[root@localhost ~]# yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils[root@localhost ~]# scl enable devtoolset-9 bash[root@localhost ~]# gcc -v 查看gcc版本[root@localhost ~]# echo &quot;source /opt/rh/devtoolset-9/enable&quot; &gt;&gt;/etc/profile 长期生效[root@localhost ~]# tar zxvf redis-6.0.6.tar.gz[root@localhost ~]# cd redis-6.0.6[root@localhost redis-6.0.6]# make MALLOC=libc[root@localhost redis-6.0.6]# mkdir -p /usr/local/redis[root@localhost redis-6.0.6]# make PREFIX=/usr/local/redis/ install[root@localhost redis-6.0.6]# cd /usr/local/redis/[root@localhost redis]# cd bin/[root@localhost bin]# ./redis-server 启动服务[root@localhost redis-6.0.6]# cp redis.conf /usr/local/redis/bin/ 拷贝配置文件[root@localhost redis-6.0.6]# cd /usr/local/redis/bin/[root@localhost bin]# vim redis.conf 编辑配置文件daemonize no=====&gt;daemonize yes 后台启动[root@localhost bin]# ./redis-server redis.conf 以后台方式启动服务[root@localhost bin]# ./redis-cli redis客户端[root@localhost bin]# vim redis.confbind 127.0.0.1=======&gt;#bind 127.0.0.1protected-mode yes==========&gt;protected-mode no#requirepass root===============&gt;requirepass root 登录加密 密码root[root@localhost bin]# ps -ef|grep redisroot 9605 1 0 20:58 ? 00:00:03 ./redis-server 127.0.0.1:6379root 9630 8696 0 21:49 pts/0 00:00:00 grep --color=auto redis[root@localhost bin]# kill -9 9605 杀进程[root@localhost bin]# ./redis-server redis.conf 重启服务[root@localhost bin]# firewall-cmd --zone=public --add-port=6379/tcp --permanent 开放端口[root@localhost bin]# firewall-cmd --reload 重启防火墙用Redis Desktop Manager连接到redis 二、redis操作数据类型1、string类型12345678910111213[root@localhost bin]# ./redis-cli -p 6379 -a root 启动客户端127.0.0.1:6379&gt; select 1 //选择数据库OK127.0.0.1:6379&gt; set name zhangsan //存值OK127.0.0.1:6379&gt; get name //取值&quot;zhangsan&quot;127.0.0.1:6379&gt; mset sex 1 address sc //一次性存多个值OK127.0.0.1:6379&gt; mget name sex address //一次性取多个值1) &quot;zhangsan&quot;2) &quot;1&quot;3) &quot;sc&quot; 2、hash类型1234567891011121314151617181920212223242526127.0.0.1:6379&gt; hset user name zhangsan(integer) 1127.0.0.1:6379&gt; hget user name&quot;zhangsan&quot;127.0.0.1:6379&gt; hset user name zhangsan(integer) 1127.0.0.1:6379&gt; hget user name&quot;zhangsan&quot;127.0.0.1:6379&gt; hmset user age 18 sex 1OK127.0.0.1:6379&gt; hmget user name age sex1) &quot;zhangsan&quot;2) &quot;18&quot;3) &quot;1&quot;127.0.0.1:6379&gt; hgetall user1) &quot;name&quot;2) &quot;zhangsan&quot;3) &quot;age&quot;4) &quot;18&quot;5) &quot;sex&quot;6) &quot;1&quot;127.0.0.1:6379&gt; hdel user name age(integer) 2127.0.0.1:6379&gt; hgetall user1) &quot;sex&quot;2) &quot;1&quot; 3、list类型1234567891011121314151617181920212223127.0.0.1:6379&gt; lpush student zhangsan lisi wangwu //左添加(integer) 3127.0.0.1:6379&gt; lrange student 0 21) &quot;wangwu&quot;2) &quot;lisi&quot;3) &quot;zhangsan&quot;127.0.0.1:6379&gt; rpush student zhaosi xiaoming //右添加(integer) 5127.0.0.1:6379&gt; lrange student 0 41) &quot;wangwu&quot;2) &quot;lisi&quot;3) &quot;zhangsan&quot;4) &quot;zhaosi&quot;5) &quot;xiaoming&quot;127.0.0.1:6379&gt; llen student //数据总数(integer) 5127.0.0.1:6379&gt; lrem student 1 xiaoming //删除数据 从左往右删(integer) 1127.0.0.1:6379&gt; lrange student 0 41) &quot;wangwu&quot;2) &quot;lisi&quot;3) &quot;zhangsan&quot;4) &quot;zhaosi&quot; 4、set类型（无序，内部排序）1234567891011121314127.0.0.1:6379&gt; sadd letters aaa bbb ccc ddd(integer) 4127.0.0.1:6379&gt; smembers letters1) &quot;bbb&quot;2) &quot;ddd&quot;3) &quot;ccc&quot;4) &quot;aaa&quot;127.0.0.1:6379&gt; scard letters //查看set的记录数(integer) 4127.0.0.1:6379&gt; srem letters aaa ccc //删除记录(integer) 2127.0.0.1:6379&gt; smembers letters1) &quot;bbb&quot;2) &quot;ddd&quot; 5、sorted set类型（排序）1234567891011121314127.0.0.1:6379&gt; zadd score 7 zhangsan 4 lisi 1 wanger //根据峰值排序(integer) 3127.0.0.1:6379&gt; zrange score 0 21) &quot;wanger&quot;2) &quot;lisi&quot;3) &quot;zhangsan&quot;127.0.0.1:6379&gt; zcard score(integer) 3127.0.0.1:6379&gt; zrem score zhangsan(integer) 1127.0.0.1:6379&gt; zrange score 0 11) &quot;wanger&quot;2) &quot;lisi&quot; 三、通用命令1234567891011121314151617181920212223242526272829303132127.0.0.1:6379&gt; set cart:user01:item01 appleOK127.0.0.1:6379&gt; get cart:user01:item01&quot;apple&quot;127.0.0.1:6379&gt; set code test ex 10 //设置失效时间OK127.0.0.1:6379&gt; ttl code(integer) 6127.0.0.1:6379&gt; get code&quot;test&quot;127.0.0.1:6379&gt; ttl code(integer) 1127.0.0.1:6379&gt; ttl code(integer) -2127.0.0.1:6379&gt; get code(nil)127.0.0.1:6379&gt; expire code 10 //已经存在的key设置失效时间(integer) 1127.0.0.1:6379&gt; ttl code(integer) 6127.0.0.1:6379&gt; get code&quot;test&quot;127.0.0.1:6379&gt; get code(nil)127.0.0.1:6379&gt; set code test px 100 xx //xx:key存在才能设置失效时间(nil)127.0.0.1:6379&gt; set code test px 100 nx //nx:key不存在设置失效时间OK127.0.0.1:6379&gt; del address //通用删除(integer) 1127.0.0.1:6379&gt; del user(integer) 1 四、java 通过 jedis连接操作redis1、添加依赖123456789101112131415161718192021222324252627282930&lt;dependencies&gt; &lt;!--redis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!--采用jedis排除lettuce依赖--&gt; &lt;exclusion&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--jedis--&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--test--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、配置文件 12345678910111213141516171819spring: redis: host: 192.168.159.180 port: 6379 password: root database: 0 #连接超时时间 timeout: 10000ms jedis: pool: #最大连接数 max-active: 1024 #最大连接阻塞等待时间 max-wait: 10000ms #最大空闲连接数 max-idle: 200 #最小空闲连接数 min-idle: 5 2、测试连接12345678910111213141516171819202122232425262728293031@Test public void initConnect()&#123; Jedis jedis=new Jedis(&quot;192.168.159.180&quot;,6379); jedis.auth(&quot;root&quot;); jedis.select(1); String result = jedis.ping(); System.out.println(result); jedis.set(&quot;name&quot;,&quot;zhangsan&quot;); String name = jedis.get(&quot;name&quot;); System.out.println(name); if (jedis!=null)&#123; jedis.close(); &#125; &#125;@Test public void initConnect02()&#123; //初始化连接池对象 JedisPool jedisPool=new JedisPool(new JedisPoolConfig(),&quot;192.168.159.180&quot;, 6379,10000,&quot;root&quot;); //从连接池获得jedis对象 Jedis jedis = jedisPool.getResource(); jedis.select(2); String result = jedis.ping(); System.out.println(result); jedis.set(&quot;name&quot;,&quot;zhangsan&quot;); String name = jedis.get(&quot;name&quot;); System.out.println(name); if (jedis!=null)&#123; jedis.close(); &#125; &#125; 3、线程池初始化一次12345678910111213141516171819202122232425262728293031323334353637@Configurationpublic class RedisConfig &#123; //服务器地址 @Value(&quot;$&#123;spring.redis.host&#125;&quot;) private String host; //服务器端口 @Value(&quot;$&#123;spring.redis.port&#125;&quot;) private int port; //访问密码 @Value(&quot;$&#123;spring.redis.password&#125;&quot;) private String password; //连接超时时间 @Value(&quot;$&#123;spring.redis.timeout&#125;&quot;) private String timeout; //最大连接数 @Value(&quot;$&#123;spring.redis.jedis.pool.max-active&#125;&quot;) private int maxTotal; //最大连接阻塞等待时间 @Value(&quot;$&#123;spring.redis.jedis.pool.max-wait&#125;&quot;) private String maxWait; //最大空闲连接数量 @Value(&quot;$&#123;spring.redis.jedis.pool.max-idle&#125;&quot;) private int maxIdle; //最小空闲连接数量 @Value(&quot;$&#123;spring.redis.jedis.pool.min-idle&#125;&quot;) private int minIdle; @Bean public JedisPool getJedisPool()&#123; JedisPoolConfig jedisPoolConfig=new JedisPoolConfig(); jedisPoolConfig.setMaxTotal(maxTotal); jedisPoolConfig.setMaxWaitMillis(Long.valueOf(maxWait.substring(0,maxWait.length()-2))); jedisPoolConfig.setMaxIdle(maxIdle); jedisPoolConfig.setMinIdle(minIdle); JedisPool jedisPool=new JedisPool(jedisPoolConfig,host,port,Integer.valueOf(timeout.substring(0,timeout.length()-2)),password); return jedisPool; &#125;&#125; 12345678910111213@Autowired private JedisPool jedisPool; private Jedis jedis=null; @BeforeAll public void initConn()&#123; jedis=jedisPool.getResource(); &#125; @AfterAll public void closetConn()&#123; if (jedis!=null)&#123; jedis.close(); &#125; &#125; 5、jedis操作string1234567891011@Test public void testHash()&#123; jedis.set(&quot;name&quot;,&quot;lisi&quot;); String s = jedis.get(&quot;name&quot;); System.out.println(s); //奇数位是key，偶数位是value jedis.mset(&quot;address&quot;,&quot;sc&quot;,&quot;sex&quot;,&quot;1&quot;); List&lt;String&gt; list = jedis.mget(&quot;name&quot;, &quot;address&quot;, &quot;sex&quot;); list.forEach(System.out::print); jedis.del(&quot;name&quot;); &#125; 6、操作hash1234567891011121314151617@Test public void testHash()&#123; jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;zhangsan&quot;); String name = jedis.hget(&quot;user&quot;, &quot;name&quot;); Map&lt;String,String&gt; map=new HashMap&lt;&gt;(); System.out.println(name); map.put(&quot;age&quot;,&quot;20&quot;); map.put(&quot;sex&quot;,&quot;1&quot;); jedis.hmset(&quot;user&quot;,map); List&lt;String&gt; list = jedis.hmget(&quot;user&quot;, &quot;age&quot;, &quot;sex&quot;); list.forEach(System.out::print); Map&lt;String, String&gt; map1 = jedis.hgetAll(&quot;user&quot;); map1.entrySet().forEach(e-&gt;&#123; System.out.println(e.getKey()+&quot;-----&gt;&quot;+e.getValue()); &#125;); jedis.hdel(&quot;user&quot;,&quot;name&quot;); &#125; 7、操作list123456789101112131415@Test public void testList()&#123; jedis.lpush(&quot;student&quot;,&quot;zhagnsan&quot;,&quot;lisi&quot;); jedis.rpush(&quot;student&quot;,&quot;wangwu&quot;,&quot;mazi&quot;); List&lt;String&gt; list = jedis.lrange(&quot;student&quot;, 0, 3); list.forEach(System.out::print); Long total = jedis.llen(&quot;student&quot;); System.out.println(total); jedis.lrem(&quot;studnet&quot;,1,&quot;lisi&quot;); //弹出要删除redis里面的数据 String left = jedis.lpop(&quot;student&quot;); String right = jedis.rpop(&quot;student&quot;); System.out.println(left); System.out.println(right); &#125; 8、操作set12345678910@Test public void testSet()&#123; jedis.sadd(&quot;demo&quot;,&quot;aaa&quot;,&quot;ccc&quot;,&quot;bbb&quot;,&quot;ggg&quot;); Set&lt;String&gt; set = jedis.smembers(&quot;demo&quot;); set.forEach(System.out::print); Long total = jedis.scard(&quot;demo&quot;); System.out.println(total); jedis.srem(&quot;demo&quot;,&quot;aaa&quot;); &#125; 9、操作sortedset123456789101112131415@Test public void SortedSet()&#123; Map&lt;String,Double&gt; map=new HashMap&lt;&gt;(); map.put(&quot;zhangsan&quot;,7D); map.put(&quot;lisi&quot;,3D); map.put(&quot;wangwu&quot;,1D); map.put(&quot;maer&quot;,4D); map.put(&quot;xiaozi&quot;,2D); jedis.zadd(&quot;qwe&quot;,map); Set&lt;String&gt; set = jedis.zrange(&quot;qwe&quot;, 0, 4); set.forEach(System.out::println); Long total = jedis.zcard(&quot;qwe&quot;); System.out.println(total); jedis.zrem(&quot;qwe&quot;,&quot;zhangsan&quot;); &#125; 10、层级目录形式存储数据123456@Testpublic void testDir()&#123; jedis.set(&quot;dir1:dir2:dir3&quot;,&quot;apple&quot;); String s = jedis.get(&quot;dir1:dir2:dir3&quot;); System.out.println(s);&#125; 11、设置失效时间1234567891011121314151617181920212223242526 @Test public void testExpire()&#123;// jedis.set(&quot;code&quot;,&quot;test&quot;);// jedis.expire(&quot;code&quot;,30); //jedis.pexpire(&quot;code&quot;,30000);// Long ttl = jedis.ttl(&quot;code&quot;);// System.out.println(ttl); // jedis.setex(&quot;code&quot;,30,&quot;test&quot;); jedis.psetex(&quot;code&quot;,30000,&quot;test&quot;); Long ttl = jedis.pttl(&quot;code&quot;); System.out.println(ttl); &#125; @Test public void testNxXx()&#123; SetParams setParams=new SetParams(); //nx xx的用法 //不存在的时候才能成功 setParams.nx(); //存在的时候才能成功 //setParams.xx(); //设置失效时间 秒 //setParams.ex(30); setParams.px(30000);//毫秒 jedis.set(&quot;code&quot;,&quot;test&quot;,setParams); &#125; 12、通用操作123456789@Test public void testComm()&#123; //查询数据库key的数量 Long size = jedis.dbSize(); System.out.println(size); //查询当前数据库的所有key Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;); keys.forEach(System.out::println); &#125; 13、事务12345678910@Test public void testMulti()&#123; //开启事务 Transaction tx = jedis.multi(); tx.set(&quot;tel&quot;,&quot;10086&quot;); //提交事务 //tx.exec(); //回滚事务 tx.discard() &#125; 14、操作byte数组123456789101112131415@Test public void testByte() throws IOException, ClassNotFoundException &#123; User user=new User(); user.setId(1); user.setUsername(&quot;zhangsan&quot;); user.setPassword(&quot;123456&quot;); //序列化为byte数组 byte[] userKey = SerializationUtils.serialize(user.getId()); byte[] userValue = SerializationUtils.serialize(user); jedis.set(userKey,userValue); byte[] bytes = jedis.get(userKey); //反序列化 User user1 = SerializationUtils.deserialize(jedis.get(bytes),User.class); System.out.println(user1); &#125; 五、redis持久化方案1、杀死进程模拟断电，redis内存数据消失1234567[root@localhost ~]# cd /usr/local/redis/bin/[root@localhost bin]# ./redis-cli -p 6379 -a rootWarning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.127.0.0.1:6379&gt; set name zhangsanOK[root@localhost bin]# kill -9 9768[root@localhost bin]# ./redis-server redis.conf 2、方案1 bgsave缺点：每次存放数据即要一次bgsave 123127.0.0.1:6379&gt; bgsaveBackground saving started 3、方案2 rdb优点：自动化 缺点：存在丢失数据 1234567891011121314151617[root@localhost bin]# vim redis.conf 338 # The filename where to dump the DB 339 dbfilename dump.rdb //持久化配置文件 [root@localhost ~]# cd /usr/local/redis/bin/[root@localhost bin]# ll总用量 18576-rw-r--r--. 1 root root 665 11月 18 07:03 dump.rdb-rwxr-xr-x. 1 root root 797760 11月 17 20:43 redis-benchmark-rwxr-xr-x. 1 root root 5664872 11月 17 20:43 redis-check-aof-rwxr-xr-x. 1 root root 5664872 11月 17 20:43 redis-check-rdb-rwxr-xr-x. 1 root root 1125272 11月 17 20:43 redis-cli-rw-r--r--. 1 root root 83387 11月 17 22:22 redis.conflrwxrwxrwx. 1 root root 12 11月 17 20:43 redis-sentinel -&gt; redis-server-rwxr-xr-x. 1 root root 5664872 11月 17 20:43 redis-serversave 900 1 //900秒内 有一个 key发生变化 就持久化到磁盘save 300 10save 60 10000 4、方案3 aof优点：实时记录命令 缺点：文件过大 加载慢 123[root@localhost bin]# vim redis.conf appendonly no===========&gt;appendonly yes //开启后命令就会追加到appendonly.aof文件appendfilename &quot;appendonly.aof&quot; 六、redis主从复用1、读写分离 ​ 2、哨兵配置主服务器挂掉，哨兵选举从服务器中的一个变成新的主服务器，具备读写能力，之前的主服务器修好后，只能变成从服务器，只有读能力。 八、redisj集群1、主从缺点：没有解决写压力，浪费资源九、SpringDataRedis1、连接redis操作string1234567891011121314151617181920212223242526&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--连接池依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 12345678910111213spring: redis: host: 192.168.159.180 port: 6379 password: root database: 0 timeout: 10000ms lettuce: pool: max-active: 1024 max-wait: 10000ms max-idle: 200 min-idle: 5 12345678910111213 @Autowired private RedisTemplate&lt;String,String&gt; redisTemplate; @Autowired private StringRedisTemplate stringRedisTemplate; @Test void contextLoads() &#123;// ValueOperations ops = redisTemplate.opsForValue();// ops.set(&quot;name&quot;,&quot;majiaxin&quot;); ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue(); ops.set(&quot;age&quot;,&quot;1&quot;); String age = ops.get(&quot;age&quot;); System.out.println(age); &#125; 2、序列化问题1234567891011121314151617@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String,Object&gt; redisTemplate(LettuceConnectionFactory lettuceConnectionFactory)&#123; RedisTemplate&lt;String,Object&gt; redisTemplate=new RedisTemplate&lt;&gt;(); //为String类型的key设置序列化 redisTemplate.setKeySerializer(new StringRedisSerializer()); //为String类型的value设置序列化 redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer()); //为hash类型的key设置序列化 redisTemplate.setHashKeySerializer(new StringRedisSerializer()); //为hash类型的value设置序列化 redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer()); redisTemplate.setConnectionFactory(lettuceConnectionFactory); return redisTemplate; &#125;&#125; 12345678910111213@Autowiredprivate RedisTemplate redisTemplate;@Testpublic void testSerial()&#123; User user=new User(); user.setId(1); user.setName(&quot;majiaxin&quot;); user.setAge(20); ValueOperations ops = redisTemplate.opsForValue(); ops.set(&quot;user&quot;,user); Object user1 = ops.get(&quot;user&quot;); System.out.println(user1);&#125; 3、操作string类型123456789101112131415161718@Test public void testString()&#123; ValueOperations ops = redisTemplate.opsForValue(); ops.set(&quot;name&quot;,&quot;test&quot;); String name = (String) ops.get(&quot;name&quot;); System.out.println(name); Map&lt;String,String&gt; map=new HashMap&lt;&gt;(); map.put(&quot;age&quot;,&quot;20&quot;); map.put(&quot;address&quot;,&quot;sc&quot;); ops.multiSet(map); List&lt;String&gt; keys=new ArrayList&lt;&gt;(); keys.add(&quot;name&quot;); keys.add(&quot;age&quot;); keys.add(&quot;address&quot;); List values = ops.multiGet(keys); values.forEach(System.out::println); redisTemplate.delete(&quot;name&quot;); &#125; 4、操作hash12345678910111213141516171819202122@Test public void testHash()&#123; HashOperations ops = redisTemplate.opsForHash(); ops.put(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;); String name = (String) ops.get(&quot;user&quot;, &quot;name&quot;); System.out.println(name); Map&lt;String,String&gt; map=new HashMap&lt;&gt;(); map.put(&quot;age&quot;,&quot;20&quot;); map.put(&quot;address&quot;,&quot;sc&quot;); ops.putAll(&quot;user&quot;,map); List&lt;String&gt; keys=new ArrayList&lt;&gt;(); keys.add(&quot;name&quot;); keys.add(&quot;age&quot;); keys.add(&quot;address&quot;); List user = ops.multiGet(&quot;user&quot;, keys); user.forEach(System.out::println); Map&lt;String,String&gt; entries = ops.entries(&quot;user&quot;); entries.entrySet().forEach(e-&gt;&#123; System.out.println(e.getKey()+&quot;--&gt;&quot;+e.getValue()); &#125;); ops.delete(&quot;user&quot;,&quot;name&quot;,&quot;age&quot;); &#125; 5、操作list12345678910111213141516@Test public void testList()&#123; ListOperations ops = redisTemplate.opsForList();// ops.leftPush(&quot;student&quot;,&quot;lisi&quot;);// ops.leftPush(&quot;student&quot;,&quot;wangwu&quot;);// ops.rightPush(&quot;student&quot;,&quot;zhaosi&quot;);// List list = ops.range(&quot;student&quot;, 0, 2);// list.forEach(System.out::println);// Long total = ops.size(&quot;student&quot;);// System.out.println(total);// ops.remove(&quot;student&quot;,1,&quot;lisi&quot;); ops.leftPush(&quot;student&quot;,&quot;zhaosi&quot;,&quot;add&quot;); ops.leftPop(&quot;student&quot;); ops.rightPop(&quot;student&quot;); &#125; 5、操作set1234567891011 @Testpublic void testSet()&#123; SetOperations ops = redisTemplate.opsForSet(); String[] letters=new String[]&#123;&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;&#125;; //ops.add(&quot;letters&quot;,&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;); ops.add(&quot;letters&quot;,letters); Set set = ops.members(&quot;letters&quot;); set.forEach(System.out::println); ops.remove(&quot;letters&quot;,&quot;aaa&quot;);&#125; 5、操作sortedSet12345678910111213141516171819@Test public void testSortedSet()&#123; ZSetOperations ops = redisTemplate.opsForZSet(); ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple1=new DefaultTypedTuple&lt;&gt;(&quot;wangwu&quot;,4D); ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple2=new DefaultTypedTuple&lt;&gt;(&quot;zhaosi&quot;,1D); ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple3=new DefaultTypedTuple&lt;&gt;(&quot;wanger&quot;,3D); ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple4=new DefaultTypedTuple&lt;&gt;(&quot;yianqi&quot;,5D); Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples=new HashSet&lt;&gt;(); tuples.add(objectTypedTuple1); tuples.add(objectTypedTuple2); tuples.add(objectTypedTuple3); tuples.add(objectTypedTuple4); ops.add(&quot;score&quot;,tuples); Set set = ops.range(&quot;score&quot;, 0, 3); set.forEach(System.out::println); Long total = ops.size(&quot;score&quot;); System.out.println(total); ops.remove(&quot;score&quot;,&quot;zhaosi&quot;); &#125; 6、通用12345678910111213141516 @Test public void testAllKey()&#123; Set keys = redisTemplate.keys(&quot;*&quot;); keys.forEach(System.out::println); &#125;@Test public void testExpire()&#123; ValueOperations ops = redisTemplate.opsForValue(); //添加key设置失效时间 //1、ops.set(&quot;code&quot;,&quot;test&quot;,30, TimeUnit.SECONDS); //给已经存在的key添加失效时间 redisTemplate.expire(&quot;code&quot;,30,TimeUnit.SECONDS); //查看失效时间 Long expire = redisTemplate.getExpire(&quot;code&quot;); System.out.println(expire); &#125; 十、key的过期淘汰机制1、定期删除redis每隔100s随机抽取一些设置了过期时间的key，检查是否过期，过期则删除 2、惰性删除有些key可能一直不会被删除，所以用户查询时，检查key是否过期，过期则删除这个key。 3、内存淘汰机制有些key用户可能一直不访问。 10、缓存击穿一个热点的Key，有大并发集中对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。 解决方案： 1、如果业务允许的话，对于热点的key可以设置永不过期的key。 2、使用互斥锁。如果缓存失效的情况，只有拿到锁才可以查询数据库，降低了在同一时刻打在数据库上的请求，防止数据库打死。当然这样会导致系统的性能变差。 11、缓存穿透我们使用Redis大部分情况都是通过Key查询对应的值，假如发送的请求传进来的key是不存在Redis中的，那么就查不到缓存，查不到缓存就会去数据库查询。假如有大量这样的请求，这些请求像“穿透”了缓存一样直接打在数据库上，这种现象就叫做缓存穿透。 12、缓存雪崩当某一个时刻出现大规模的缓存失效的情况，那么就会导致大量的请求直接打在数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。 解决方案： 1、在原有的失效时间上加上一个随机值，比如1-5分钟随机。这样就避免了因为采用相同的过期时间导致的缓存雪崩。 如果真的发生了缓存雪崩，有没有什么兜底的措施？ 2、使用熔断机制。当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上。至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。 3、提高数据库的容灾能力，可以使用分库分表，读写分离的策略。 4、为了防止Redis宕机导致缓存雪崩的问题，可以搭建Redis集群，提高Redis的容灾性。","categories":[{"name":"redis","slug":"redis","permalink":"http://example.com/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]}],"categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"jdk8新特性","slug":"java/jdk8新特性","permalink":"http://example.com/categories/java/jdk8%E6%96%B0%E7%89%B9%E6%80%A7/"},{"name":"zookeeper","slug":"zookeeper","permalink":"http://example.com/categories/zookeeper/"},{"name":"dubbo","slug":"dubbo","permalink":"http://example.com/categories/dubbo/"},{"name":"spring","slug":"spring","permalink":"http://example.com/categories/spring/"},{"name":"springsecurity","slug":"spring/springsecurity","permalink":"http://example.com/categories/spring/springsecurity/"},{"name":"redis","slug":"redis","permalink":"http://example.com/categories/redis/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"zookeeper","slug":"zookeeper","permalink":"http://example.com/tags/zookeeper/"},{"name":"dubbo","slug":"dubbo","permalink":"http://example.com/tags/dubbo/"},{"name":"springsecurity","slug":"springsecurity","permalink":"http://example.com/tags/springsecurity/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]}