{"meta":{"title":"三金弟弟'blog","subtitle":"","description":"","author":"sanjindidi","url":"http://example.com","root":"/"},"pages":[{"title":"所有分类","date":"2021-11-21T18:39:09.906Z","updated":"2021-11-21T18:39:09.906Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-11-21T18:37:41.016Z","updated":"2021-11-21T18:37:41.016Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-11-21T21:29:51.352Z","updated":"2021-11-21T21:29:51.352Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"","date":"2021-11-21T21:38:33.441Z","updated":"2021-11-21T21:38:33.441Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"}],"posts":[{"title":"redis","slug":"redis","date":"2021-11-21T23:18:08.000Z","updated":"2021-11-21T23:22:40.293Z","comments":true,"path":"2021/11/22/redis/","link":"","permalink":"http://example.com/2021/11/22/redis/","excerpt":"","text":"1、安装1、下载redis.tar.gz传输至linux2、编译启动服务12345678910111213141516171819202122232425262728293031[root@localhost ~]# yum -y install centos-release-scl[root@localhost ~]# yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils[root@localhost ~]# scl enable devtoolset-9 bash[root@localhost ~]# gcc -v 查看gcc版本[root@localhost ~]# echo &quot;source /opt/rh/devtoolset-9/enable&quot; &gt;&gt;/etc/profile 长期生效[root@localhost ~]# tar zxvf redis-6.0.6.tar.gz[root@localhost ~]# cd redis-6.0.6[root@localhost redis-6.0.6]# make MALLOC=libc[root@localhost redis-6.0.6]# mkdir -p /usr/local/redis[root@localhost redis-6.0.6]# make PREFIX=/usr/local/redis/ install[root@localhost redis-6.0.6]# cd /usr/local/redis/[root@localhost redis]# cd bin/[root@localhost bin]# ./redis-server 启动服务[root@localhost redis-6.0.6]# cp redis.conf /usr/local/redis/bin/ 拷贝配置文件[root@localhost redis-6.0.6]# cd /usr/local/redis/bin/[root@localhost bin]# vim redis.conf 编辑配置文件daemonize no=====&gt;daemonize yes 后台启动[root@localhost bin]# ./redis-server redis.conf 以后台方式启动服务[root@localhost bin]# ./redis-cli redis客户端[root@localhost bin]# vim redis.confbind 127.0.0.1=======&gt;#bind 127.0.0.1protected-mode yes==========&gt;protected-mode no#requirepass root===============&gt;requirepass root 登录加密 密码root[root@localhost bin]# ps -ef|grep redisroot 9605 1 0 20:58 ? 00:00:03 ./redis-server 127.0.0.1:6379root 9630 8696 0 21:49 pts/0 00:00:00 grep --color=auto redis[root@localhost bin]# kill -9 9605 杀进程[root@localhost bin]# ./redis-server redis.conf 重启服务[root@localhost bin]# firewall-cmd --zone=public --add-port=6379/tcp --permanent 开放端口[root@localhost bin]# firewall-cmd --reload 重启防火墙用Redis Desktop Manager连接到redis 2、redis操作1、string类型12345678910111213[root@localhost bin]# ./redis-cli -p 6379 -a root 启动客户端127.0.0.1:6379&gt; select 1 //选择数据库OK127.0.0.1:6379&gt; set name zhangsan //存值OK127.0.0.1:6379&gt; get name //取值&quot;zhangsan&quot;127.0.0.1:6379&gt; mset sex 1 address sc //一次性存多个值OK127.0.0.1:6379&gt; mget name sex address //一次性取多个值1) &quot;zhangsan&quot;2) &quot;1&quot;3) &quot;sc&quot; 2、hash类型1234567891011121314151617181920212223242526127.0.0.1:6379&gt; hset user name zhangsan(integer) 1127.0.0.1:6379&gt; hget user name&quot;zhangsan&quot;127.0.0.1:6379&gt; hset user name zhangsan(integer) 1127.0.0.1:6379&gt; hget user name&quot;zhangsan&quot;127.0.0.1:6379&gt; hmset user age 18 sex 1OK127.0.0.1:6379&gt; hmget user name age sex1) &quot;zhangsan&quot;2) &quot;18&quot;3) &quot;1&quot;127.0.0.1:6379&gt; hgetall user1) &quot;name&quot;2) &quot;zhangsan&quot;3) &quot;age&quot;4) &quot;18&quot;5) &quot;sex&quot;6) &quot;1&quot;127.0.0.1:6379&gt; hdel user name age(integer) 2127.0.0.1:6379&gt; hgetall user1) &quot;sex&quot;2) &quot;1&quot; 3、list类型1234567891011121314151617181920212223127.0.0.1:6379&gt; lpush student zhangsan lisi wangwu //左添加(integer) 3127.0.0.1:6379&gt; lrange student 0 21) &quot;wangwu&quot;2) &quot;lisi&quot;3) &quot;zhangsan&quot;127.0.0.1:6379&gt; rpush student zhaosi xiaoming //右添加(integer) 5127.0.0.1:6379&gt; lrange student 0 41) &quot;wangwu&quot;2) &quot;lisi&quot;3) &quot;zhangsan&quot;4) &quot;zhaosi&quot;5) &quot;xiaoming&quot;127.0.0.1:6379&gt; llen student //数据总数(integer) 5127.0.0.1:6379&gt; lrem student 1 xiaoming //删除数据 从左往右删(integer) 1127.0.0.1:6379&gt; lrange student 0 41) &quot;wangwu&quot;2) &quot;lisi&quot;3) &quot;zhangsan&quot;4) &quot;zhaosi&quot; 4、set类型（无序，内部排序）1234567891011121314127.0.0.1:6379&gt; sadd letters aaa bbb ccc ddd(integer) 4127.0.0.1:6379&gt; smembers letters1) &quot;bbb&quot;2) &quot;ddd&quot;3) &quot;ccc&quot;4) &quot;aaa&quot;127.0.0.1:6379&gt; scard letters //查看set的记录数(integer) 4127.0.0.1:6379&gt; srem letters aaa ccc //删除记录(integer) 2127.0.0.1:6379&gt; smembers letters1) &quot;bbb&quot;2) &quot;ddd&quot; 5、sorted set类型（排序）1234567891011121314127.0.0.1:6379&gt; zadd score 7 zhangsan 4 lisi 1 wanger //根据峰值排序(integer) 3127.0.0.1:6379&gt; zrange score 0 21) &quot;wanger&quot;2) &quot;lisi&quot;3) &quot;zhangsan&quot;127.0.0.1:6379&gt; zcard score(integer) 3127.0.0.1:6379&gt; zrem score zhangsan(integer) 1127.0.0.1:6379&gt; zrange score 0 11) &quot;wanger&quot;2) &quot;lisi&quot; 3、通用命令1234567891011121314151617181920212223242526272829303132127.0.0.1:6379&gt; set cart:user01:item01 appleOK127.0.0.1:6379&gt; get cart:user01:item01&quot;apple&quot;127.0.0.1:6379&gt; set code test ex 10 //设置失效时间OK127.0.0.1:6379&gt; ttl code(integer) 6127.0.0.1:6379&gt; get code&quot;test&quot;127.0.0.1:6379&gt; ttl code(integer) 1127.0.0.1:6379&gt; ttl code(integer) -2127.0.0.1:6379&gt; get code(nil)127.0.0.1:6379&gt; expire code 10 //已经存在的key设置失效时间(integer) 1127.0.0.1:6379&gt; ttl code(integer) 6127.0.0.1:6379&gt; get code&quot;test&quot;127.0.0.1:6379&gt; get code(nil)127.0.0.1:6379&gt; set code test px 100 xx //xx:key存在才能设置失效时间(nil)127.0.0.1:6379&gt; set code test px 100 nx //nx:key不存在设置失效时间OK127.0.0.1:6379&gt; del address //通用删除(integer) 1127.0.0.1:6379&gt; del user(integer) 1 4、java 通过 jedis连接操作redis1、添加依赖123456789101112131415161718192021222324252627282930&lt;dependencies&gt; &lt;!--redis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!--采用jedis排除lettuce依赖--&gt; &lt;exclusion&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--jedis--&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--test--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、配置文件 12345678910111213141516171819spring: redis: host: 192.168.159.180 port: 6379 password: root database: 0 #连接超时时间 timeout: 10000ms jedis: pool: #最大连接数 max-active: 1024 #最大连接阻塞等待时间 max-wait: 10000ms #最大空闲连接数 max-idle: 200 #最小空闲连接数 min-idle: 5 2、测试连接12345678910111213141516171819202122232425262728293031@Test public void initConnect()&#123; Jedis jedis=new Jedis(&quot;192.168.159.180&quot;,6379); jedis.auth(&quot;root&quot;); jedis.select(1); String result = jedis.ping(); System.out.println(result); jedis.set(&quot;name&quot;,&quot;zhangsan&quot;); String name = jedis.get(&quot;name&quot;); System.out.println(name); if (jedis!=null)&#123; jedis.close(); &#125; &#125;@Test public void initConnect02()&#123; //初始化连接池对象 JedisPool jedisPool=new JedisPool(new JedisPoolConfig(),&quot;192.168.159.180&quot;, 6379,10000,&quot;root&quot;); //从连接池获得jedis对象 Jedis jedis = jedisPool.getResource(); jedis.select(2); String result = jedis.ping(); System.out.println(result); jedis.set(&quot;name&quot;,&quot;zhangsan&quot;); String name = jedis.get(&quot;name&quot;); System.out.println(name); if (jedis!=null)&#123; jedis.close(); &#125; &#125; 3、线程池初始化一次12345678910111213141516171819202122232425262728293031323334353637@Configurationpublic class RedisConfig &#123; //服务器地址 @Value(&quot;$&#123;spring.redis.host&#125;&quot;) private String host; //服务器端口 @Value(&quot;$&#123;spring.redis.port&#125;&quot;) private int port; //访问密码 @Value(&quot;$&#123;spring.redis.password&#125;&quot;) private String password; //连接超时时间 @Value(&quot;$&#123;spring.redis.timeout&#125;&quot;) private String timeout; //最大连接数 @Value(&quot;$&#123;spring.redis.jedis.pool.max-active&#125;&quot;) private int maxTotal; //最大连接阻塞等待时间 @Value(&quot;$&#123;spring.redis.jedis.pool.max-wait&#125;&quot;) private String maxWait; //最大空闲连接数量 @Value(&quot;$&#123;spring.redis.jedis.pool.max-idle&#125;&quot;) private int maxIdle; //最小空闲连接数量 @Value(&quot;$&#123;spring.redis.jedis.pool.min-idle&#125;&quot;) private int minIdle; @Bean public JedisPool getJedisPool()&#123; JedisPoolConfig jedisPoolConfig=new JedisPoolConfig(); jedisPoolConfig.setMaxTotal(maxTotal); jedisPoolConfig.setMaxWaitMillis(Long.valueOf(maxWait.substring(0,maxWait.length()-2))); jedisPoolConfig.setMaxIdle(maxIdle); jedisPoolConfig.setMinIdle(minIdle); JedisPool jedisPool=new JedisPool(jedisPoolConfig,host,port,Integer.valueOf(timeout.substring(0,timeout.length()-2)),password); return jedisPool; &#125;&#125; 12345678910111213@Autowired private JedisPool jedisPool; private Jedis jedis=null; @BeforeAll public void initConn()&#123; jedis=jedisPool.getResource(); &#125; @AfterAll public void closetConn()&#123; if (jedis!=null)&#123; jedis.close(); &#125; &#125; 5、jedis操作string1234567891011@Test public void testHash()&#123; jedis.set(&quot;name&quot;,&quot;lisi&quot;); String s = jedis.get(&quot;name&quot;); System.out.println(s); //奇数位是key，偶数位是value jedis.mset(&quot;address&quot;,&quot;sc&quot;,&quot;sex&quot;,&quot;1&quot;); List&lt;String&gt; list = jedis.mget(&quot;name&quot;, &quot;address&quot;, &quot;sex&quot;); list.forEach(System.out::print); jedis.del(&quot;name&quot;); &#125; 6、操作hash1234567891011121314151617@Test public void testHash()&#123; jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;zhangsan&quot;); String name = jedis.hget(&quot;user&quot;, &quot;name&quot;); Map&lt;String,String&gt; map=new HashMap&lt;&gt;(); System.out.println(name); map.put(&quot;age&quot;,&quot;20&quot;); map.put(&quot;sex&quot;,&quot;1&quot;); jedis.hmset(&quot;user&quot;,map); List&lt;String&gt; list = jedis.hmget(&quot;user&quot;, &quot;age&quot;, &quot;sex&quot;); list.forEach(System.out::print); Map&lt;String, String&gt; map1 = jedis.hgetAll(&quot;user&quot;); map1.entrySet().forEach(e-&gt;&#123; System.out.println(e.getKey()+&quot;-----&gt;&quot;+e.getValue()); &#125;); jedis.hdel(&quot;user&quot;,&quot;name&quot;); &#125; 7、操作list123456789101112131415@Test public void testList()&#123; jedis.lpush(&quot;student&quot;,&quot;zhagnsan&quot;,&quot;lisi&quot;); jedis.rpush(&quot;student&quot;,&quot;wangwu&quot;,&quot;mazi&quot;); List&lt;String&gt; list = jedis.lrange(&quot;student&quot;, 0, 3); list.forEach(System.out::print); Long total = jedis.llen(&quot;student&quot;); System.out.println(total); jedis.lrem(&quot;studnet&quot;,1,&quot;lisi&quot;); //弹出要删除redis里面的数据 String left = jedis.lpop(&quot;student&quot;); String right = jedis.rpop(&quot;student&quot;); System.out.println(left); System.out.println(right); &#125; 8、操作set12345678910@Test public void testSet()&#123; jedis.sadd(&quot;demo&quot;,&quot;aaa&quot;,&quot;ccc&quot;,&quot;bbb&quot;,&quot;ggg&quot;); Set&lt;String&gt; set = jedis.smembers(&quot;demo&quot;); set.forEach(System.out::print); Long total = jedis.scard(&quot;demo&quot;); System.out.println(total); jedis.srem(&quot;demo&quot;,&quot;aaa&quot;); &#125; 9、操作sortedset123456789101112131415@Test public void SortedSet()&#123; Map&lt;String,Double&gt; map=new HashMap&lt;&gt;(); map.put(&quot;zhangsan&quot;,7D); map.put(&quot;lisi&quot;,3D); map.put(&quot;wangwu&quot;,1D); map.put(&quot;maer&quot;,4D); map.put(&quot;xiaozi&quot;,2D); jedis.zadd(&quot;qwe&quot;,map); Set&lt;String&gt; set = jedis.zrange(&quot;qwe&quot;, 0, 4); set.forEach(System.out::println); Long total = jedis.zcard(&quot;qwe&quot;); System.out.println(total); jedis.zrem(&quot;qwe&quot;,&quot;zhangsan&quot;); &#125; 10、层级目录形式存储数据123456@Testpublic void testDir()&#123; jedis.set(&quot;dir1:dir2:dir3&quot;,&quot;apple&quot;); String s = jedis.get(&quot;dir1:dir2:dir3&quot;); System.out.println(s);&#125; 11、设置失效时间1234567891011121314151617181920212223242526 @Test public void testExpire()&#123;// jedis.set(&quot;code&quot;,&quot;test&quot;);// jedis.expire(&quot;code&quot;,30); //jedis.pexpire(&quot;code&quot;,30000);// Long ttl = jedis.ttl(&quot;code&quot;);// System.out.println(ttl); // jedis.setex(&quot;code&quot;,30,&quot;test&quot;); jedis.psetex(&quot;code&quot;,30000,&quot;test&quot;); Long ttl = jedis.pttl(&quot;code&quot;); System.out.println(ttl); &#125; @Test public void testNxXx()&#123; SetParams setParams=new SetParams(); //nx xx的用法 //不存在的时候才能成功 setParams.nx(); //存在的时候才能成功 //setParams.xx(); //设置失效时间 秒 //setParams.ex(30); setParams.px(30000);//毫秒 jedis.set(&quot;code&quot;,&quot;test&quot;,setParams); &#125; 12、通用操作123456789@Test public void testComm()&#123; //查询数据库key的数量 Long size = jedis.dbSize(); System.out.println(size); //查询当前数据库的所有key Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;); keys.forEach(System.out::println); &#125; 13、事务12345678910@Test public void testMulti()&#123; //开启事务 Transaction tx = jedis.multi(); tx.set(&quot;tel&quot;,&quot;10086&quot;); //提交事务 //tx.exec(); //回滚事务 tx.discard() &#125; 14、操作byte数组123456789101112131415@Test public void testByte() throws IOException, ClassNotFoundException &#123; User user=new User(); user.setId(1); user.setUsername(&quot;zhangsan&quot;); user.setPassword(&quot;123456&quot;); //序列化为byte数组 byte[] userKey = SerializationUtils.serialize(user.getId()); byte[] userValue = SerializationUtils.serialize(user); jedis.set(userKey,userValue); byte[] bytes = jedis.get(userKey); //反序列化 User user1 = SerializationUtils.deserialize(jedis.get(bytes),User.class); System.out.println(user1); &#125; 5、redis持久化方案1、杀死进程模拟断电，redis内存数据消失1234567[root@localhost ~]# cd /usr/local/redis/bin/[root@localhost bin]# ./redis-cli -p 6379 -a rootWarning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.127.0.0.1:6379&gt; set name zhangsanOK[root@localhost bin]# kill -9 9768[root@localhost bin]# ./redis-server redis.conf 2、方案1 bgsave缺点：每次存放数据即要一次bgsave 123127.0.0.1:6379&gt; bgsaveBackground saving started 3、方案2 rdb优点：自动化 缺点：存在丢失数据 1234567891011121314151617[root@localhost bin]# vim redis.conf 338 # The filename where to dump the DB 339 dbfilename dump.rdb //持久化配置文件 [root@localhost ~]# cd /usr/local/redis/bin/[root@localhost bin]# ll总用量 18576-rw-r--r--. 1 root root 665 11月 18 07:03 dump.rdb-rwxr-xr-x. 1 root root 797760 11月 17 20:43 redis-benchmark-rwxr-xr-x. 1 root root 5664872 11月 17 20:43 redis-check-aof-rwxr-xr-x. 1 root root 5664872 11月 17 20:43 redis-check-rdb-rwxr-xr-x. 1 root root 1125272 11月 17 20:43 redis-cli-rw-r--r--. 1 root root 83387 11月 17 22:22 redis.conflrwxrwxrwx. 1 root root 12 11月 17 20:43 redis-sentinel -&gt; redis-server-rwxr-xr-x. 1 root root 5664872 11月 17 20:43 redis-serversave 900 1 //900秒内 有一个 key发生变化 就持久化到磁盘save 300 10save 60 10000 4、方案3 aof优点：实时记录命令 缺点：文件过大 加载慢 123[root@localhost bin]# vim redis.conf appendonly no===========&gt;appendonly yes //开启后命令就会追加到appendonly.aof文件appendfilename &quot;appendonly.aof&quot; 6、redis主从复用1、读写分离 ​ 2、哨兵配置主服务器挂掉，哨兵选举从服务器中的一个变成新的主服务器，具备读写能力，之前的主服务器修好后，只能变成从服务器，只有读能力。 7、redisj集群1、主从缺点：没有解决写压力，浪费资源8、SpringDataRedis1、连接redis操作string1234567891011121314151617181920212223242526&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--连接池依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 12345678910111213spring: redis: host: 192.168.159.180 port: 6379 password: root database: 0 timeout: 10000ms lettuce: pool: max-active: 1024 max-wait: 10000ms max-idle: 200 min-idle: 5 12345678910111213 @Autowired private RedisTemplate&lt;String,String&gt; redisTemplate; @Autowired private StringRedisTemplate stringRedisTemplate; @Test void contextLoads() &#123;// ValueOperations ops = redisTemplate.opsForValue();// ops.set(&quot;name&quot;,&quot;majiaxin&quot;); ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue(); ops.set(&quot;age&quot;,&quot;1&quot;); String age = ops.get(&quot;age&quot;); System.out.println(age); &#125; 2、序列化问题1234567891011121314151617@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String,Object&gt; redisTemplate(LettuceConnectionFactory lettuceConnectionFactory)&#123; RedisTemplate&lt;String,Object&gt; redisTemplate=new RedisTemplate&lt;&gt;(); //为String类型的key设置序列化 redisTemplate.setKeySerializer(new StringRedisSerializer()); //为String类型的value设置序列化 redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer()); //为hash类型的key设置序列化 redisTemplate.setHashKeySerializer(new StringRedisSerializer()); //为hash类型的value设置序列化 redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer()); redisTemplate.setConnectionFactory(lettuceConnectionFactory); return redisTemplate; &#125;&#125; 12345678910111213@Autowiredprivate RedisTemplate redisTemplate;@Testpublic void testSerial()&#123; User user=new User(); user.setId(1); user.setName(&quot;majiaxin&quot;); user.setAge(20); ValueOperations ops = redisTemplate.opsForValue(); ops.set(&quot;user&quot;,user); Object user1 = ops.get(&quot;user&quot;); System.out.println(user1);&#125; 3、操作string类型123456789101112131415161718@Test public void testString()&#123; ValueOperations ops = redisTemplate.opsForValue(); ops.set(&quot;name&quot;,&quot;test&quot;); String name = (String) ops.get(&quot;name&quot;); System.out.println(name); Map&lt;String,String&gt; map=new HashMap&lt;&gt;(); map.put(&quot;age&quot;,&quot;20&quot;); map.put(&quot;address&quot;,&quot;sc&quot;); ops.multiSet(map); List&lt;String&gt; keys=new ArrayList&lt;&gt;(); keys.add(&quot;name&quot;); keys.add(&quot;age&quot;); keys.add(&quot;address&quot;); List values = ops.multiGet(keys); values.forEach(System.out::println); redisTemplate.delete(&quot;name&quot;); &#125; 4、操作hash12345678910111213141516171819202122@Test public void testHash()&#123; HashOperations ops = redisTemplate.opsForHash(); ops.put(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;); String name = (String) ops.get(&quot;user&quot;, &quot;name&quot;); System.out.println(name); Map&lt;String,String&gt; map=new HashMap&lt;&gt;(); map.put(&quot;age&quot;,&quot;20&quot;); map.put(&quot;address&quot;,&quot;sc&quot;); ops.putAll(&quot;user&quot;,map); List&lt;String&gt; keys=new ArrayList&lt;&gt;(); keys.add(&quot;name&quot;); keys.add(&quot;age&quot;); keys.add(&quot;address&quot;); List user = ops.multiGet(&quot;user&quot;, keys); user.forEach(System.out::println); Map&lt;String,String&gt; entries = ops.entries(&quot;user&quot;); entries.entrySet().forEach(e-&gt;&#123; System.out.println(e.getKey()+&quot;--&gt;&quot;+e.getValue()); &#125;); ops.delete(&quot;user&quot;,&quot;name&quot;,&quot;age&quot;); &#125; 5、操作list12345678910111213141516@Test public void testList()&#123; ListOperations ops = redisTemplate.opsForList();// ops.leftPush(&quot;student&quot;,&quot;lisi&quot;);// ops.leftPush(&quot;student&quot;,&quot;wangwu&quot;);// ops.rightPush(&quot;student&quot;,&quot;zhaosi&quot;);// List list = ops.range(&quot;student&quot;, 0, 2);// list.forEach(System.out::println);// Long total = ops.size(&quot;student&quot;);// System.out.println(total);// ops.remove(&quot;student&quot;,1,&quot;lisi&quot;); ops.leftPush(&quot;student&quot;,&quot;zhaosi&quot;,&quot;add&quot;); ops.leftPop(&quot;student&quot;); ops.rightPop(&quot;student&quot;); &#125; 5、操作set1234567891011 @Testpublic void testSet()&#123; SetOperations ops = redisTemplate.opsForSet(); String[] letters=new String[]&#123;&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;&#125;; //ops.add(&quot;letters&quot;,&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;); ops.add(&quot;letters&quot;,letters); Set set = ops.members(&quot;letters&quot;); set.forEach(System.out::println); ops.remove(&quot;letters&quot;,&quot;aaa&quot;);&#125; 5、操作sortedSet12345678910111213141516171819@Test public void testSortedSet()&#123; ZSetOperations ops = redisTemplate.opsForZSet(); ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple1=new DefaultTypedTuple&lt;&gt;(&quot;wangwu&quot;,4D); ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple2=new DefaultTypedTuple&lt;&gt;(&quot;zhaosi&quot;,1D); ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple3=new DefaultTypedTuple&lt;&gt;(&quot;wanger&quot;,3D); ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple4=new DefaultTypedTuple&lt;&gt;(&quot;yianqi&quot;,5D); Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples=new HashSet&lt;&gt;(); tuples.add(objectTypedTuple1); tuples.add(objectTypedTuple2); tuples.add(objectTypedTuple3); tuples.add(objectTypedTuple4); ops.add(&quot;score&quot;,tuples); Set set = ops.range(&quot;score&quot;, 0, 3); set.forEach(System.out::println); Long total = ops.size(&quot;score&quot;); System.out.println(total); ops.remove(&quot;score&quot;,&quot;zhaosi&quot;); &#125; 6、通用12345678910111213141516 @Test public void testAllKey()&#123; Set keys = redisTemplate.keys(&quot;*&quot;); keys.forEach(System.out::println); &#125;@Test public void testExpire()&#123; ValueOperations ops = redisTemplate.opsForValue(); //添加key设置失效时间 //1、ops.set(&quot;code&quot;,&quot;test&quot;,30, TimeUnit.SECONDS); //给已经存在的key添加失效时间 redisTemplate.expire(&quot;code&quot;,30,TimeUnit.SECONDS); //查看失效时间 Long expire = redisTemplate.getExpire(&quot;code&quot;); System.out.println(expire); &#125; 9、key的过期淘汰机制1、定期删除redis每隔100s随机抽取一些设置了过期时间的key，检查是否过期，过期则删除 2、惰性删除有些key可能一直不会被删除，所以用户查询时，检查key是否过期，过期则删除这个key。3、内存淘汰机制有些key用户可能一直不访问。 10、缓存击穿一个热点的Key，有大并发集中对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。解决方案：1、如果业务允许的话，对于热点的key可以设置永不过期的key。2、使用互斥锁。如果缓存失效的情况，只有拿到锁才可以查询数据库，降低了在同一时刻打在数据库上的请求，防止数据库打死。当然这样会导致系统的性能变差。 11、缓存穿透我们使用Redis大部分情况都是通过Key查询对应的值，假如发送的请求传进来的key是不存在Redis中的，那么就查不到缓存，查不到缓存就会去数据库查询。假如有大量这样的请求，这些请求像“穿透”了缓存一样直接打在数据库上，这种现象就叫做缓存穿透。 12、缓存雪崩当某一个时刻出现大规模的缓存失效的情况，那么就会导致大量的请求直接打在数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。解决方案：1、在原有的失效时间上加上一个随机值，比如1-5分钟随机。这样就避免了因为采用相同的过期时间导致的缓存雪崩。如果真的发生了缓存雪崩，有没有什么兜底的措施？2、使用熔断机制。当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上。至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。3、提高数据库的容灾能力，可以使用分库分表，读写分离的策略。4、为了防止Redis宕机导致缓存雪崩的问题，可以搭建Redis集群，提高Redis的容灾性。","categories":[{"name":"redis","slug":"redis","permalink":"http://example.com/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]}],"categories":[{"name":"redis","slug":"redis","permalink":"http://example.com/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]}